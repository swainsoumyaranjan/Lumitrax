{"version":3,"file":"room-receipts.js","names":["_read_receipts","require","_client","_room","_logger","RoomReceipts","constructor","room","_defineProperty2","default","event","eventId","getId","danglingReceipts","remove","forEach","danglingReceipt","receipt","thread_id","threadedReceipts","set","receiptType","userId","ts","synthetic","unthreadedReceipts","ThreadedReceipts","ReceiptsByUser","DanglingReceipts","on","RoomEvent","Timeline","onTimelineEvent","add","receiptContent","eventReceipt","Object","entries","receiptsByUser","referencedEvent","findEventById","DanglingReceipt","hasUserReadEvent","unthreaded","get","isAfterOrSame","logger","warn","roomId","threadId","threadIdForReceipt","threaded","userSentLatestEventInThread","_this$room$getThread","timeline","MAIN_ROOM_TIMELINE","getLiveTimeline","getEvents","getThread","length","getSender","exports","ReceiptInfo","UserReceipts","real","undefined","receiptInfo","_this$synthetic","getByType","data","Map","userReceipts","getOrCreate","existingReceipt","isAfter","_this$data$get","_this$data$get2","push","delete","m","key","createFn","found","created","leftEventId","rightEventId","comparison","compareEventOrdering"],"sources":["../../src/models/room-receipts.ts"],"sourcesContent":["/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { MAIN_ROOM_TIMELINE, Receipt, ReceiptContent } from \"../@types/read_receipts\";\nimport { threadIdForReceipt } from \"../client\";\nimport { Room, RoomEvent } from \"./room\";\nimport { MatrixEvent } from \"./event\";\nimport { logger } from \"../logger\";\n\n/**\n * The latest receipts we have for a room.\n */\nexport class RoomReceipts {\n    private room: Room;\n    private threadedReceipts: ThreadedReceipts;\n    private unthreadedReceipts: ReceiptsByUser;\n    private danglingReceipts: DanglingReceipts;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.threadedReceipts = new ThreadedReceipts(room);\n        this.unthreadedReceipts = new ReceiptsByUser(room);\n        this.danglingReceipts = new DanglingReceipts();\n        // We listen for timeline events so we can process dangling receipts\n        room.on(RoomEvent.Timeline, this.onTimelineEvent);\n    }\n\n    /**\n     * Remember the receipt information supplied. For each receipt:\n     *\n     * If we don't have the event for this receipt, store it as \"dangling\" so we\n     * can process it later.\n     *\n     * Otherwise store it per-user in either the threaded store for its\n     * thread_id, or the unthreaded store if there is no thread_id.\n     *\n     * Ignores any receipt that is before an existing receipt for the same user\n     * (in the same thread, if applicable). \"Before\" is defined by the\n     * unfilteredTimelineSet of the room.\n     */\n    public add(receiptContent: ReceiptContent, synthetic: boolean): void {\n        /*\n            Transform this structure:\n            {\n              \"$EVENTID\": {\n                \"m.read|m.read.private\": {\n                  \"@user:example.org\": {\n                    \"ts\": 1661,\n                    \"thread_id\": \"main|$THREAD_ROOT_ID\" // or missing/undefined for an unthreaded receipt\n                  }\n                }\n              },\n              ...\n            }\n            into maps of:\n            threaded :: threadid :: userId :: ReceiptInfo\n            unthreaded :: userId :: ReceiptInfo\n            dangling :: eventId :: DanglingReceipt\n        */\n        for (const [eventId, eventReceipt] of Object.entries(receiptContent)) {\n            for (const [receiptType, receiptsByUser] of Object.entries(eventReceipt)) {\n                for (const [userId, receipt] of Object.entries(receiptsByUser)) {\n                    const referencedEvent = this.room.findEventById(eventId);\n                    if (!referencedEvent) {\n                        this.danglingReceipts.add(\n                            new DanglingReceipt(eventId, receiptType, userId, receipt, synthetic),\n                        );\n                    } else if (receipt.thread_id) {\n                        this.threadedReceipts.set(\n                            receipt.thread_id,\n                            eventId,\n                            receiptType,\n                            userId,\n                            receipt.ts,\n                            synthetic,\n                        );\n                    } else {\n                        this.unthreadedReceipts.set(eventId, receiptType, userId, receipt.ts, synthetic);\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Look for dangling receipts for the given event ID,\n     * and add them to the thread of unthread receipts if found.\n     * @param eventId - the event ID to look for\n     */\n    private onTimelineEvent = (event: MatrixEvent): void => {\n        const eventId = event.getId();\n        if (!eventId) return;\n\n        const danglingReceipts = this.danglingReceipts.remove(eventId);\n\n        danglingReceipts?.forEach((danglingReceipt) => {\n            // The receipt is a thread receipt\n            if (danglingReceipt.receipt.thread_id) {\n                this.threadedReceipts.set(\n                    danglingReceipt.receipt.thread_id,\n                    danglingReceipt.eventId,\n                    danglingReceipt.receiptType,\n                    danglingReceipt.userId,\n                    danglingReceipt.receipt.ts,\n                    danglingReceipt.synthetic,\n                );\n            } else {\n                this.unthreadedReceipts.set(\n                    eventId,\n                    danglingReceipt.receiptType,\n                    danglingReceipt.userId,\n                    danglingReceipt.receipt.ts,\n                    danglingReceipt.synthetic,\n                );\n            }\n        });\n    };\n\n    public hasUserReadEvent(userId: string, eventId: string): boolean {\n        const unthreaded = this.unthreadedReceipts.get(userId);\n        if (unthreaded) {\n            if (isAfterOrSame(unthreaded.eventId, eventId, this.room)) {\n                // The unthreaded receipt is after this event, so we have read it.\n                return true;\n            }\n        }\n\n        const event = this.room.findEventById(eventId);\n        if (!event) {\n            // We don't know whether the user has read it - default to caution and say no.\n            // This shouldn't really happen and feels like it ought to be an exception: let's\n            // log a warn for now.\n            logger.warn(\n                `hasUserReadEvent event ID ${eventId} not found in room ${this.room.roomId}: this shouldn't happen!`,\n            );\n            return false;\n        }\n\n        const threadId = threadIdForReceipt(event);\n        const threaded = this.threadedReceipts.get(threadId, userId);\n        if (threaded) {\n            if (isAfterOrSame(threaded.eventId, eventId, this.room)) {\n                // The threaded receipt is after this event, so we have read it.\n                return true;\n            }\n        }\n\n        // TODO: what if they sent the second-last event in the thread?\n        if (this.userSentLatestEventInThread(threadId, userId)) {\n            // The user sent the latest message in this event's thread, so we\n            // consider everything in the thread to be read.\n            //\n            // Note: maybe we don't need this because synthetic receipts should\n            // do this job for us?\n            return true;\n        }\n\n        // Neither of the receipts were after the event, so it's unread.\n        return false;\n    }\n\n    /**\n     * @returns true if the thread with this ID can be found, and the supplied\n     *          user sent the latest message in it.\n     */\n    private userSentLatestEventInThread(threadId: string, userId: String): boolean {\n        const timeline =\n            threadId === MAIN_ROOM_TIMELINE\n                ? this.room.getLiveTimeline().getEvents()\n                : this.room.getThread(threadId)?.timeline;\n\n        return !!(timeline && timeline.length > 0 && timeline[timeline.length - 1].getSender() === userId);\n    }\n}\n\n// --- implementation details ---\n\n/**\n * The information \"inside\" a receipt once it has been stored inside\n * RoomReceipts - what eventId it refers to, its type, and its ts.\n *\n * Does not contain userId or threadId since these are stored as keys of the\n * maps in RoomReceipts.\n */\nclass ReceiptInfo {\n    public constructor(public eventId: string, public receiptType: string, public ts: number) {}\n}\n\n/**\n * Everything we know about a receipt that is \"dangling\" because we can't find\n * the event to which it refers.\n */\nclass DanglingReceipt {\n    public constructor(\n        public eventId: string,\n        public receiptType: string,\n        public userId: string,\n        public receipt: Receipt,\n        public synthetic: boolean,\n    ) {}\n}\n\nclass UserReceipts {\n    private room: Room;\n\n    /**\n     * The real receipt for this user.\n     */\n    private real: ReceiptInfo | undefined;\n\n    /**\n     * The synthetic receipt for this user. If this is defined, it is later than real.\n     */\n    private synthetic: ReceiptInfo | undefined;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.real = undefined;\n        this.synthetic = undefined;\n    }\n\n    public set(synthetic: boolean, receiptInfo: ReceiptInfo): void {\n        if (synthetic) {\n            this.synthetic = receiptInfo;\n        } else {\n            this.real = receiptInfo;\n        }\n\n        // Preserve the invariant: synthetic is only defined if it's later than real\n        if (this.synthetic && this.real) {\n            if (isAfterOrSame(this.real.eventId, this.synthetic.eventId, this.room)) {\n                this.synthetic = undefined;\n            }\n        }\n    }\n\n    /**\n     * Return the latest receipt we have - synthetic if we have one (and it's\n     * later), otherwise real.\n     */\n    public get(): ReceiptInfo | undefined {\n        // Relies on the invariant that synthetic is only defined if it's later than real.\n        return this.synthetic ?? this.real;\n    }\n\n    /**\n     * Return the latest receipt we have of the specified type (synthetic or not).\n     */\n    public getByType(synthetic: boolean): ReceiptInfo | undefined {\n        return synthetic ? this.synthetic : this.real;\n    }\n}\n\n/**\n * The latest receipt info we have, either for a single thread, or all the\n * unthreaded receipts for a room.\n *\n * userId: ReceiptInfo\n */\nclass ReceiptsByUser {\n    private room: Room;\n\n    /** map of userId: UserReceipts */\n    private data: Map<String, UserReceipts>;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.data = new Map<string, UserReceipts>();\n    }\n\n    /**\n     * Add the supplied receipt to our structure, if it is not earlier than the\n     * one we already hold for this user.\n     */\n    public set(eventId: string, receiptType: string, userId: string, ts: number, synthetic: boolean): void {\n        const userReceipts = getOrCreate(this.data, userId, () => new UserReceipts(this.room));\n\n        const existingReceipt = userReceipts.getByType(synthetic);\n        if (existingReceipt && isAfter(existingReceipt.eventId, eventId, this.room)) {\n            // The new receipt is before the existing one - don't store it.\n            return;\n        }\n\n        // Possibilities:\n        //\n        // 1. there was no existing receipt, or\n        // 2. the existing receipt was before this one, or\n        // 3. we were unable to compare the receipts.\n        //\n        // In the case of 3 it's difficult to decide what to do, so the\n        // most-recently-received receipt wins.\n        //\n        // Case 3 can only happen if the events for these receipts have\n        // disappeared, which is quite unlikely since the new one has just been\n        // checked, and the old one was checked before it was inserted here.\n        //\n        // We go ahead and store this receipt (replacing the other if it exists)\n        userReceipts.set(synthetic, new ReceiptInfo(eventId, receiptType, ts));\n    }\n\n    /**\n     * Find the latest receipt we have for this user. (Note - there is only one\n     * receipt per user, because we are already inside a specific thread or\n     * unthreaded list.)\n     *\n     * If there is a later synthetic receipt for this user, return that.\n     * Otherwise, return the real receipt.\n     *\n     * @returns the found receipt info, or undefined if we have no receipt for this user.\n     */\n    public get(userId: string): ReceiptInfo | undefined {\n        return this.data.get(userId)?.get();\n    }\n}\n\n/**\n * The latest threaded receipts we have for a room.\n */\nclass ThreadedReceipts {\n    private room: Room;\n\n    /** map of threadId: ReceiptsByUser */\n    private data: Map<string, ReceiptsByUser>;\n\n    public constructor(room: Room) {\n        this.room = room;\n        this.data = new Map<string, ReceiptsByUser>();\n    }\n\n    /**\n     * Add the supplied receipt to our structure, if it is not earlier than one\n     * we already hold for this user in this thread.\n     */\n    public set(\n        threadId: string,\n        eventId: string,\n        receiptType: string,\n        userId: string,\n        ts: number,\n        synthetic: boolean,\n    ): void {\n        const receiptsByUser = getOrCreate(this.data, threadId, () => new ReceiptsByUser(this.room));\n        receiptsByUser.set(eventId, receiptType, userId, ts, synthetic);\n    }\n\n    /**\n     * Find the latest threaded receipt for the supplied user in the supplied thread.\n     *\n     * @returns the found receipt info or undefined if we don't have one.\n     */\n    public get(threadId: string, userId: string): ReceiptInfo | undefined {\n        return this.data.get(threadId)?.get(userId);\n    }\n}\n\n/**\n * All the receipts that we have received but can't process because we can't\n * find the event they refer to.\n *\n * We hold on to them so we can process them if their event arrives later.\n */\nclass DanglingReceipts {\n    /**\n     * eventId: DanglingReceipt[]\n     */\n    private data = new Map<string, Array<DanglingReceipt>>();\n\n    /**\n     * Remember the supplied dangling receipt.\n     */\n    public add(danglingReceipt: DanglingReceipt): void {\n        const danglingReceipts = getOrCreate(this.data, danglingReceipt.eventId, () => []);\n        danglingReceipts.push(danglingReceipt);\n    }\n\n    /**\n     * Remove and return the dangling receipts for the given event ID.\n     * @param eventId - the event ID to look for\n     * @returns the found dangling receipts, or undefined if we don't have one.\n     */\n    public remove(eventId: string): Array<DanglingReceipt> | undefined {\n        const danglingReceipts = this.data.get(eventId);\n        this.data.delete(eventId);\n        return danglingReceipts;\n    }\n}\n\nfunction getOrCreate<K, V>(m: Map<K, V>, key: K, createFn: () => V): V {\n    const found = m.get(key);\n    if (found) {\n        return found;\n    } else {\n        const created = createFn();\n        m.set(key, created);\n        return created;\n    }\n}\n\n/**\n * Is left after right (or the same)?\n *\n * Only returns true if both events can be found, and left is after or the same\n * as right.\n *\n * @returns left \\>= right\n */\nfunction isAfterOrSame(leftEventId: string, rightEventId: string, room: Room): boolean {\n    const comparison = room.compareEventOrdering(leftEventId, rightEventId);\n    return comparison !== null && comparison >= 0;\n}\n\n/**\n * Is left strictly after right?\n *\n * Only returns true if both events can be found, and left is strictly after right.\n *\n * @returns left \\> right\n */\nfunction isAfter(leftEventId: string, rightEventId: string, room: Room): boolean {\n    const comparison = room.compareEventOrdering(leftEventId, rightEventId);\n    return comparison !== null && comparison > 0;\n}\n"],"mappings":";;;;;;;;AAgBA,IAAAA,cAAA,GAAAC,OAAA;AACA,IAAAC,OAAA,GAAAD,OAAA;AACA,IAAAE,KAAA,GAAAF,OAAA;AAEA,IAAAG,OAAA,GAAAH,OAAA;AApBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAQA;AACA;AACA;AACO,MAAMI,YAAY,CAAC;EAMfC,WAAWA,CAACC,IAAU,EAAE;IAkE/B;AACJ;AACA;AACA;AACA;IAJI,IAAAC,gBAAA,CAAAC,OAAA,2BAK2BC,KAAkB,IAAW;MACpD,MAAMC,OAAO,GAAGD,KAAK,CAACE,KAAK,CAAC,CAAC;MAC7B,IAAI,CAACD,OAAO,EAAE;MAEd,MAAME,gBAAgB,GAAG,IAAI,CAACA,gBAAgB,CAACC,MAAM,CAACH,OAAO,CAAC;MAE9DE,gBAAgB,aAAhBA,gBAAgB,eAAhBA,gBAAgB,CAAEE,OAAO,CAAEC,eAAe,IAAK;QAC3C;QACA,IAAIA,eAAe,CAACC,OAAO,CAACC,SAAS,EAAE;UACnC,IAAI,CAACC,gBAAgB,CAACC,GAAG,CACrBJ,eAAe,CAACC,OAAO,CAACC,SAAS,EACjCF,eAAe,CAACL,OAAO,EACvBK,eAAe,CAACK,WAAW,EAC3BL,eAAe,CAACM,MAAM,EACtBN,eAAe,CAACC,OAAO,CAACM,EAAE,EAC1BP,eAAe,CAACQ,SACpB,CAAC;QACL,CAAC,MAAM;UACH,IAAI,CAACC,kBAAkB,CAACL,GAAG,CACvBT,OAAO,EACPK,eAAe,CAACK,WAAW,EAC3BL,eAAe,CAACM,MAAM,EACtBN,eAAe,CAACC,OAAO,CAACM,EAAE,EAC1BP,eAAe,CAACQ,SACpB,CAAC;QACL;MACJ,CAAC,CAAC;IACN,CAAC;IAjGG,IAAI,CAACjB,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACY,gBAAgB,GAAG,IAAIO,gBAAgB,CAACnB,IAAI,CAAC;IAClD,IAAI,CAACkB,kBAAkB,GAAG,IAAIE,cAAc,CAACpB,IAAI,CAAC;IAClD,IAAI,CAACM,gBAAgB,GAAG,IAAIe,gBAAgB,CAAC,CAAC;IAC9C;IACArB,IAAI,CAACsB,EAAE,CAACC,eAAS,CAACC,QAAQ,EAAE,IAAI,CAACC,eAAe,CAAC;EACrD;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACWC,GAAGA,CAACC,cAA8B,EAAEV,SAAkB,EAAQ;IACjE;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACQ,KAAK,MAAM,CAACb,OAAO,EAAEwB,YAAY,CAAC,IAAIC,MAAM,CAACC,OAAO,CAACH,cAAc,CAAC,EAAE;MAClE,KAAK,MAAM,CAACb,WAAW,EAAEiB,cAAc,CAAC,IAAIF,MAAM,CAACC,OAAO,CAACF,YAAY,CAAC,EAAE;QACtE,KAAK,MAAM,CAACb,MAAM,EAAEL,OAAO,CAAC,IAAImB,MAAM,CAACC,OAAO,CAACC,cAAc,CAAC,EAAE;UAC5D,MAAMC,eAAe,GAAG,IAAI,CAAChC,IAAI,CAACiC,aAAa,CAAC7B,OAAO,CAAC;UACxD,IAAI,CAAC4B,eAAe,EAAE;YAClB,IAAI,CAAC1B,gBAAgB,CAACoB,GAAG,CACrB,IAAIQ,eAAe,CAAC9B,OAAO,EAAEU,WAAW,EAAEC,MAAM,EAAEL,OAAO,EAAEO,SAAS,CACxE,CAAC;UACL,CAAC,MAAM,IAAIP,OAAO,CAACC,SAAS,EAAE;YAC1B,IAAI,CAACC,gBAAgB,CAACC,GAAG,CACrBH,OAAO,CAACC,SAAS,EACjBP,OAAO,EACPU,WAAW,EACXC,MAAM,EACNL,OAAO,CAACM,EAAE,EACVC,SACJ,CAAC;UACL,CAAC,MAAM;YACH,IAAI,CAACC,kBAAkB,CAACL,GAAG,CAACT,OAAO,EAAEU,WAAW,EAAEC,MAAM,EAAEL,OAAO,CAACM,EAAE,EAAEC,SAAS,CAAC;UACpF;QACJ;MACJ;IACJ;EACJ;EAoCOkB,gBAAgBA,CAACpB,MAAc,EAAEX,OAAe,EAAW;IAC9D,MAAMgC,UAAU,GAAG,IAAI,CAAClB,kBAAkB,CAACmB,GAAG,CAACtB,MAAM,CAAC;IACtD,IAAIqB,UAAU,EAAE;MACZ,IAAIE,aAAa,CAACF,UAAU,CAAChC,OAAO,EAAEA,OAAO,EAAE,IAAI,CAACJ,IAAI,CAAC,EAAE;QACvD;QACA,OAAO,IAAI;MACf;IACJ;IAEA,MAAMG,KAAK,GAAG,IAAI,CAACH,IAAI,CAACiC,aAAa,CAAC7B,OAAO,CAAC;IAC9C,IAAI,CAACD,KAAK,EAAE;MACR;MACA;MACA;MACAoC,cAAM,CAACC,IAAI,CACN,6BAA4BpC,OAAQ,sBAAqB,IAAI,CAACJ,IAAI,CAACyC,MAAO,0BAC/E,CAAC;MACD,OAAO,KAAK;IAChB;IAEA,MAAMC,QAAQ,GAAG,IAAAC,0BAAkB,EAACxC,KAAK,CAAC;IAC1C,MAAMyC,QAAQ,GAAG,IAAI,CAAChC,gBAAgB,CAACyB,GAAG,CAACK,QAAQ,EAAE3B,MAAM,CAAC;IAC5D,IAAI6B,QAAQ,EAAE;MACV,IAAIN,aAAa,CAACM,QAAQ,CAACxC,OAAO,EAAEA,OAAO,EAAE,IAAI,CAACJ,IAAI,CAAC,EAAE;QACrD;QACA,OAAO,IAAI;MACf;IACJ;;IAEA;IACA,IAAI,IAAI,CAAC6C,2BAA2B,CAACH,QAAQ,EAAE3B,MAAM,CAAC,EAAE;MACpD;MACA;MACA;MACA;MACA;MACA,OAAO,IAAI;IACf;;IAEA;IACA,OAAO,KAAK;EAChB;;EAEA;AACJ;AACA;AACA;EACY8B,2BAA2BA,CAACH,QAAgB,EAAE3B,MAAc,EAAW;IAAA,IAAA+B,oBAAA;IAC3E,MAAMC,QAAQ,GACVL,QAAQ,KAAKM,iCAAkB,GACzB,IAAI,CAAChD,IAAI,CAACiD,eAAe,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC,IAAAJ,oBAAA,GACvC,IAAI,CAAC9C,IAAI,CAACmD,SAAS,CAACT,QAAQ,CAAC,cAAAI,oBAAA,uBAA7BA,oBAAA,CAA+BC,QAAQ;IAEjD,OAAO,CAAC,EAAEA,QAAQ,IAAIA,QAAQ,CAACK,MAAM,GAAG,CAAC,IAAIL,QAAQ,CAACA,QAAQ,CAACK,MAAM,GAAG,CAAC,CAAC,CAACC,SAAS,CAAC,CAAC,KAAKtC,MAAM,CAAC;EACtG;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANAuC,OAAA,CAAAxD,YAAA,GAAAA,YAAA;AAOA,MAAMyD,WAAW,CAAC;EACPxD,WAAWA,CAAQK,OAAe,EAASU,WAAmB,EAASE,EAAU,EAAE;IAAA,KAAhEZ,OAAe,GAAfA,OAAe;IAAA,KAASU,WAAmB,GAAnBA,WAAmB;IAAA,KAASE,EAAU,GAAVA,EAAU;EAAG;AAC/F;;AAEA;AACA;AACA;AACA;AACA,MAAMkB,eAAe,CAAC;EACXnC,WAAWA,CACPK,OAAe,EACfU,WAAmB,EACnBC,MAAc,EACdL,OAAgB,EAChBO,SAAkB,EAC3B;IAAA,KALSb,OAAe,GAAfA,OAAe;IAAA,KACfU,WAAmB,GAAnBA,WAAmB;IAAA,KACnBC,MAAc,GAAdA,MAAc;IAAA,KACdL,OAAgB,GAAhBA,OAAgB;IAAA,KAChBO,SAAkB,GAAlBA,SAAkB;EAC1B;AACP;AAEA,MAAMuC,YAAY,CAAC;EAGf;AACJ;AACA;;EAGI;AACJ;AACA;;EAGWzD,WAAWA,CAACC,IAAU,EAAE;IAC3B,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB,IAAI,CAACyD,IAAI,GAAGC,SAAS;IACrB,IAAI,CAACzC,SAAS,GAAGyC,SAAS;EAC9B;EAEO7C,GAAGA,CAACI,SAAkB,EAAE0C,WAAwB,EAAQ;IAC3D,IAAI1C,SAAS,EAAE;MACX,IAAI,CAACA,SAAS,GAAG0C,WAAW;IAChC,CAAC,MAAM;MACH,IAAI,CAACF,IAAI,GAAGE,WAAW;IAC3B;;IAEA;IACA,IAAI,IAAI,CAAC1C,SAAS,IAAI,IAAI,CAACwC,IAAI,EAAE;MAC7B,IAAInB,aAAa,CAAC,IAAI,CAACmB,IAAI,CAACrD,OAAO,EAAE,IAAI,CAACa,SAAS,CAACb,OAAO,EAAE,IAAI,CAACJ,IAAI,CAAC,EAAE;QACrE,IAAI,CAACiB,SAAS,GAAGyC,SAAS;MAC9B;IACJ;EACJ;;EAEA;AACJ;AACA;AACA;EACWrB,GAAGA,CAAA,EAA4B;IAAA,IAAAuB,eAAA;IAClC;IACA,QAAAA,eAAA,GAAO,IAAI,CAAC3C,SAAS,cAAA2C,eAAA,cAAAA,eAAA,GAAI,IAAI,CAACH,IAAI;EACtC;;EAEA;AACJ;AACA;EACWI,SAASA,CAAC5C,SAAkB,EAA2B;IAC1D,OAAOA,SAAS,GAAG,IAAI,CAACA,SAAS,GAAG,IAAI,CAACwC,IAAI;EACjD;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMrC,cAAc,CAAC;EAGjB;;EAGOrB,WAAWA,CAACC,IAAU,EAAE;IAC3B,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC8D,IAAI,GAAG,IAAIC,GAAG,CAAuB,CAAC;EAC/C;;EAEA;AACJ;AACA;AACA;EACWlD,GAAGA,CAACT,OAAe,EAAEU,WAAmB,EAAEC,MAAc,EAAEC,EAAU,EAAEC,SAAkB,EAAQ;IACnG,MAAM+C,YAAY,GAAGC,WAAW,CAAC,IAAI,CAACH,IAAI,EAAE/C,MAAM,EAAE,MAAM,IAAIyC,YAAY,CAAC,IAAI,CAACxD,IAAI,CAAC,CAAC;IAEtF,MAAMkE,eAAe,GAAGF,YAAY,CAACH,SAAS,CAAC5C,SAAS,CAAC;IACzD,IAAIiD,eAAe,IAAIC,OAAO,CAACD,eAAe,CAAC9D,OAAO,EAAEA,OAAO,EAAE,IAAI,CAACJ,IAAI,CAAC,EAAE;MACzE;MACA;IACJ;;IAEA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACAgE,YAAY,CAACnD,GAAG,CAACI,SAAS,EAAE,IAAIsC,WAAW,CAACnD,OAAO,EAAEU,WAAW,EAAEE,EAAE,CAAC,CAAC;EAC1E;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACWqB,GAAGA,CAACtB,MAAc,EAA2B;IAAA,IAAAqD,cAAA;IAChD,QAAAA,cAAA,GAAO,IAAI,CAACN,IAAI,CAACzB,GAAG,CAACtB,MAAM,CAAC,cAAAqD,cAAA,uBAArBA,cAAA,CAAuB/B,GAAG,CAAC,CAAC;EACvC;AACJ;;AAEA;AACA;AACA;AACA,MAAMlB,gBAAgB,CAAC;EAGnB;;EAGOpB,WAAWA,CAACC,IAAU,EAAE;IAC3B,IAAI,CAACA,IAAI,GAAGA,IAAI;IAChB,IAAI,CAAC8D,IAAI,GAAG,IAAIC,GAAG,CAAyB,CAAC;EACjD;;EAEA;AACJ;AACA;AACA;EACWlD,GAAGA,CACN6B,QAAgB,EAChBtC,OAAe,EACfU,WAAmB,EACnBC,MAAc,EACdC,EAAU,EACVC,SAAkB,EACd;IACJ,MAAMc,cAAc,GAAGkC,WAAW,CAAC,IAAI,CAACH,IAAI,EAAEpB,QAAQ,EAAE,MAAM,IAAItB,cAAc,CAAC,IAAI,CAACpB,IAAI,CAAC,CAAC;IAC5F+B,cAAc,CAAClB,GAAG,CAACT,OAAO,EAAEU,WAAW,EAAEC,MAAM,EAAEC,EAAE,EAAEC,SAAS,CAAC;EACnE;;EAEA;AACJ;AACA;AACA;AACA;EACWoB,GAAGA,CAACK,QAAgB,EAAE3B,MAAc,EAA2B;IAAA,IAAAsD,eAAA;IAClE,QAAAA,eAAA,GAAO,IAAI,CAACP,IAAI,CAACzB,GAAG,CAACK,QAAQ,CAAC,cAAA2B,eAAA,uBAAvBA,eAAA,CAAyBhC,GAAG,CAACtB,MAAM,CAAC;EAC/C;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMM,gBAAgB,CAAC;EAAAtB,YAAA;IACnB;AACJ;AACA;IAFI,IAAAE,gBAAA,CAAAC,OAAA,gBAGe,IAAI6D,GAAG,CAAiC,CAAC;EAAA;EAExD;AACJ;AACA;EACWrC,GAAGA,CAACjB,eAAgC,EAAQ;IAC/C,MAAMH,gBAAgB,GAAG2D,WAAW,CAAC,IAAI,CAACH,IAAI,EAAErD,eAAe,CAACL,OAAO,EAAE,MAAM,EAAE,CAAC;IAClFE,gBAAgB,CAACgE,IAAI,CAAC7D,eAAe,CAAC;EAC1C;;EAEA;AACJ;AACA;AACA;AACA;EACWF,MAAMA,CAACH,OAAe,EAAsC;IAC/D,MAAME,gBAAgB,GAAG,IAAI,CAACwD,IAAI,CAACzB,GAAG,CAACjC,OAAO,CAAC;IAC/C,IAAI,CAAC0D,IAAI,CAACS,MAAM,CAACnE,OAAO,CAAC;IACzB,OAAOE,gBAAgB;EAC3B;AACJ;AAEA,SAAS2D,WAAWA,CAAOO,CAAY,EAAEC,GAAM,EAAEC,QAAiB,EAAK;EACnE,MAAMC,KAAK,GAAGH,CAAC,CAACnC,GAAG,CAACoC,GAAG,CAAC;EACxB,IAAIE,KAAK,EAAE;IACP,OAAOA,KAAK;EAChB,CAAC,MAAM;IACH,MAAMC,OAAO,GAAGF,QAAQ,CAAC,CAAC;IAC1BF,CAAC,CAAC3D,GAAG,CAAC4D,GAAG,EAAEG,OAAO,CAAC;IACnB,OAAOA,OAAO;EAClB;AACJ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAStC,aAAaA,CAACuC,WAAmB,EAAEC,YAAoB,EAAE9E,IAAU,EAAW;EACnF,MAAM+E,UAAU,GAAG/E,IAAI,CAACgF,oBAAoB,CAACH,WAAW,EAAEC,YAAY,CAAC;EACvE,OAAOC,UAAU,KAAK,IAAI,IAAIA,UAAU,IAAI,CAAC;AACjD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASZ,OAAOA,CAACU,WAAmB,EAAEC,YAAoB,EAAE9E,IAAU,EAAW;EAC7E,MAAM+E,UAAU,GAAG/E,IAAI,CAACgF,oBAAoB,CAACH,WAAW,EAAEC,YAAY,CAAC;EACvE,OAAOC,UAAU,KAAK,IAAI,IAAIA,UAAU,GAAG,CAAC;AAChD"}