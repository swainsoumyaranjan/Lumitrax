{"version":3,"file":"backup.js","names":["_client","require","_logger","_olmlib","_key_passphrase","_utils","_indexeddbCryptoStore","_recoverykey","_aes","_NamespacedValue","_index","_crypto","_httpApi","KEY_BACKUP_KEYS_PER_REQUEST","KEY_BACKUP_CHECK_RATE_LIMIT","BackupManager","constructor","baseApis","getKey","_defineProperty2","default","checkedForBackup","sendingBackups","stop","clientRunning","version","backupInfo","checkBackupVersion","info","Algorithm","algorithmsByName","algorithm","Error","auth_data","makeAlgorithm","init","enableKeyBackup","free","emit","CryptoEvent","KeyBackupStatus","scheduleKeyBackupSend","disableKeyBackup","undefined","getKeyBackupEnabled","Boolean","prepareKeyBackupVersion","key","DefaultAlgorithm","privateKey","authData","prepare","recoveryKey","encodeRecoveryKey","algorithmName","recovery_key","createKeyBackupVersion","deleteAllKeyBackupVersions","_await$this$baseApis$","_await$this$baseApis$2","current","getKeyBackupVersion","_await$this$baseApis$3","_await$this$baseApis$4","deleteKeyBackupVersion","path","encodeUri","$version","http","authedRequest","Method","Delete","prefix","ClientPrefix","V3","checkAndStart","logger","log","isGuest","_await$this$baseApis$5","e","httpStatus","trustInfo","isKeyBackupTrusted","usable","scheduleAllGroupSessionsForBackup","checkKeyBackup","queryKeyBackupRateLimited","targetRoomId","targetSessionId","now","Date","getTime","sessionLastCheckAttemptedTime","restoreKeyBackupWithCache","ret","trusted_locally","sigs","signatures","JSON","stringify","userId","getUserId","privKey","crypto","getSessionBackupPrivateKey","keyMatches","_algorithm","mySigs","keyId","Object","keys","keyIdParts","split","sigInfo","deviceId","crossSigningId","crossSigningInfo","getId","verifySignature","olmDevice","valid","warn","push","device","deviceList","getStoredDevice","deviceTrust","checkDeviceTrust","getFingerprint","some","s","_s$deviceTrust","isVerified","maxDelay","debug","delay","Math","random","sleep","numFailures","numBackedUp","backupPendingKeys","err","MatrixError","errCode","data","errcode","KeyBackupFailed","pow","min","limit","sessions","cryptoStore","getSessionsNeedingBackup","length","remaining","countSessionsNeedingBackup","KeyBackupSessionsRemaining","rooms","session","_deviceList$getDevice","roomId","sessionData","room_id","safeSet","exportInboundGroupSession","senderKey","sessionId","MEGOLM_ALGORITHM","forwardedCount","forwarding_curve25519_key_chain","getUserByIdentityKey","getDeviceByIdentityKey","verified","checkDeviceInfoTrust","first_message_index","first_known_index","forwarded_count","is_verified","session_data","encryptSession","sendKeyBackup","unmarkSessionsNeedingBackup","backupGroupSession","markSessionsNeedingBackup","flagAllGroupSessionsForBackup","doTxn","IndexedDBCryptoStore","STORE_INBOUND_GROUP_SESSIONS","STORE_BACKUP","txn","getAllEndToEndInboundGroupSessions","exports","Curve25519","publicKey","global","Olm","PkEncryption","set_recipient_key","public_key","decryption","PkDecryption","generate_key","Uint8Array","init_with_private_key","derivation","keyFromPassphrase","private_key_salt","salt","private_key_iterations","iterations","get_private_key","untrusted","plainText","assign","session_id","encrypt","decryptSessions","backupPubKey","MatrixClient","RESTORE_BACKUP_ERROR_BAD_KEY","entries","decrypted","parse","decrypt","ephemeral","mac","ciphertext","pubKey","randomBytes","size","buf","getRandomValues","UNSTABLE_MSC3270_NAME","UnstableValue","Aes256","calculateKeyCheck","iv","replace","outKey","encryptAES","decryptAES","fill","name","backupTrustInfoFromLegacyTrustInfo","_trustInfo$trusted_lo","trusted","matchesDecryptionKey","LibOlmBackupDecryptor","sourceTrusted"],"sources":["../../src/crypto/backup.ts"],"sourcesContent":["/*\nCopyright 2021 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/**\n * Classes for dealing with key backup.\n */\n\nimport type { IMegolmSessionData } from \"../@types/crypto\";\nimport { MatrixClient } from \"../client\";\nimport { logger } from \"../logger\";\nimport { MEGOLM_ALGORITHM, verifySignature } from \"./olmlib\";\nimport { DeviceInfo } from \"./deviceinfo\";\nimport { DeviceTrustLevel } from \"./CrossSigning\";\nimport { keyFromPassphrase } from \"./key_passphrase\";\nimport { encodeUri, safeSet, sleep } from \"../utils\";\nimport { IndexedDBCryptoStore } from \"./store/indexeddb-crypto-store\";\nimport { encodeRecoveryKey } from \"./recoverykey\";\nimport { calculateKeyCheck, decryptAES, encryptAES, IEncryptedPayload } from \"./aes\";\nimport {\n    Curve25519SessionData,\n    IAes256AuthData,\n    ICurve25519AuthData,\n    IKeyBackupInfo,\n    IKeyBackupSession,\n} from \"./keybackup\";\nimport { UnstableValue } from \"../NamespacedValue\";\nimport { CryptoEvent } from \"./index\";\nimport { crypto } from \"./crypto\";\nimport { ClientPrefix, HTTPError, MatrixError, Method } from \"../http-api\";\nimport { BackupTrustInfo } from \"../crypto-api/keybackup\";\nimport { BackupDecryptor } from \"../common-crypto/CryptoBackend\";\n\nconst KEY_BACKUP_KEYS_PER_REQUEST = 200;\nconst KEY_BACKUP_CHECK_RATE_LIMIT = 5000; // ms\n\ntype AuthData = IKeyBackupInfo[\"auth_data\"];\n\ntype SigInfo = {\n    deviceId: string;\n    valid?: boolean | null; // true: valid, false: invalid, null: cannot attempt validation\n    device?: DeviceInfo | null;\n    crossSigningId?: boolean;\n    deviceTrust?: DeviceTrustLevel;\n};\n\n/** @deprecated Prefer {@link BackupTrustInfo} */\nexport type TrustInfo = {\n    usable: boolean; // is the backup trusted, true iff there is a sig that is valid & from a trusted device\n    sigs: SigInfo[];\n    // eslint-disable-next-line camelcase\n    trusted_locally?: boolean;\n};\n\nexport interface IKeyBackupCheck {\n    backupInfo?: IKeyBackupInfo;\n    trustInfo: TrustInfo;\n}\n\n/* eslint-disable camelcase */\nexport interface IPreparedKeyBackupVersion {\n    algorithm: string;\n    auth_data: AuthData;\n    recovery_key: string;\n    privateKey: Uint8Array;\n}\n/* eslint-enable camelcase */\n\n/** A function used to get the secret key for a backup.\n */\ntype GetKey = () => Promise<ArrayLike<number>>;\n\ninterface BackupAlgorithmClass {\n    algorithmName: string;\n    // initialize from an existing backup\n    init(authData: AuthData, getKey: GetKey): Promise<BackupAlgorithm>;\n\n    // prepare a brand new backup\n    prepare(key?: string | Uint8Array | null): Promise<[Uint8Array, AuthData]>;\n\n    checkBackupVersion(info: IKeyBackupInfo): void;\n}\n\ninterface BackupAlgorithm {\n    untrusted: boolean;\n    encryptSession(data: Record<string, any>): Promise<Curve25519SessionData | IEncryptedPayload>;\n    decryptSessions(ciphertexts: Record<string, IKeyBackupSession>): Promise<IMegolmSessionData[]>;\n    authData: AuthData;\n    keyMatches(key: ArrayLike<number>): Promise<boolean>;\n    free(): void;\n}\n\nexport interface IKeyBackup {\n    rooms: {\n        [roomId: string]: {\n            sessions: {\n                [sessionId: string]: IKeyBackupSession;\n            };\n        };\n    };\n}\n\n/**\n * Manages the key backup.\n */\nexport class BackupManager {\n    private algorithm: BackupAlgorithm | undefined;\n    public backupInfo: IKeyBackupInfo | undefined; // The info dict from /room_keys/version\n    public checkedForBackup: boolean; // Have we checked the server for a backup we can use?\n    private sendingBackups: boolean; // Are we currently sending backups?\n    private sessionLastCheckAttemptedTime: Record<string, number> = {}; // When did we last try to check the server for a given session id?\n    // The backup manager will schedule backup of keys when active (`scheduleKeyBackupSend`), this allows cancel when client is stopped\n    private clientRunning = true;\n\n    public constructor(private readonly baseApis: MatrixClient, public readonly getKey: GetKey) {\n        this.checkedForBackup = false;\n        this.sendingBackups = false;\n    }\n\n    /**\n     * Stop the backup manager from backing up keys and allow a clean shutdown.\n     */\n    public stop(): void {\n        this.clientRunning = false;\n    }\n\n    public get version(): string | undefined {\n        return this.backupInfo && this.backupInfo.version;\n    }\n\n    /**\n     * Performs a quick check to ensure that the backup info looks sane.\n     *\n     * Throws an error if a problem is detected.\n     *\n     * @param info - the key backup info\n     */\n    public static checkBackupVersion(info: IKeyBackupInfo): void {\n        const Algorithm = algorithmsByName[info.algorithm];\n        if (!Algorithm) {\n            throw new Error(\"Unknown backup algorithm: \" + info.algorithm);\n        }\n        if (typeof info.auth_data !== \"object\") {\n            throw new Error(\"Invalid backup data returned\");\n        }\n        return Algorithm.checkBackupVersion(info);\n    }\n\n    public static makeAlgorithm(info: IKeyBackupInfo, getKey: GetKey): Promise<BackupAlgorithm> {\n        const Algorithm = algorithmsByName[info.algorithm];\n        if (!Algorithm) {\n            throw new Error(\"Unknown backup algorithm\");\n        }\n        return Algorithm.init(info.auth_data, getKey);\n    }\n\n    public async enableKeyBackup(info: IKeyBackupInfo): Promise<void> {\n        this.backupInfo = info;\n        if (this.algorithm) {\n            this.algorithm.free();\n        }\n\n        this.algorithm = await BackupManager.makeAlgorithm(info, this.getKey);\n\n        this.baseApis.emit(CryptoEvent.KeyBackupStatus, true);\n\n        // There may be keys left over from a partially completed backup, so\n        // schedule a send to check.\n        this.scheduleKeyBackupSend();\n    }\n\n    /**\n     * Disable backing up of keys.\n     */\n    public disableKeyBackup(): void {\n        if (this.algorithm) {\n            this.algorithm.free();\n        }\n        this.algorithm = undefined;\n\n        this.backupInfo = undefined;\n\n        this.baseApis.emit(CryptoEvent.KeyBackupStatus, false);\n    }\n\n    public getKeyBackupEnabled(): boolean | null {\n        if (!this.checkedForBackup) {\n            return null;\n        }\n        return Boolean(this.algorithm);\n    }\n\n    public async prepareKeyBackupVersion(\n        key?: string | Uint8Array | null,\n        algorithm?: string | undefined,\n    ): Promise<IPreparedKeyBackupVersion> {\n        const Algorithm = algorithm ? algorithmsByName[algorithm] : DefaultAlgorithm;\n        if (!Algorithm) {\n            throw new Error(\"Unknown backup algorithm\");\n        }\n\n        const [privateKey, authData] = await Algorithm.prepare(key);\n        const recoveryKey = encodeRecoveryKey(privateKey)!;\n        return {\n            algorithm: Algorithm.algorithmName,\n            auth_data: authData,\n            recovery_key: recoveryKey,\n            privateKey,\n        };\n    }\n\n    public async createKeyBackupVersion(info: IKeyBackupInfo): Promise<void> {\n        this.algorithm = await BackupManager.makeAlgorithm(info, this.getKey);\n    }\n\n    /**\n     * Deletes all key backups.\n     *\n     * Will call the API to delete active backup until there is no more present.\n     */\n    public async deleteAllKeyBackupVersions(): Promise<void> {\n        // there could be several backup versions, delete all to be safe.\n        let current = (await this.baseApis.getKeyBackupVersion())?.version ?? null;\n        while (current != null) {\n            await this.deleteKeyBackupVersion(current);\n            this.disableKeyBackup();\n            current = (await this.baseApis.getKeyBackupVersion())?.version ?? null;\n        }\n    }\n\n    /**\n     * Deletes the given key backup.\n     *\n     * @param version - The backup version to delete.\n     */\n    public async deleteKeyBackupVersion(version: string): Promise<void> {\n        const path = encodeUri(\"/room_keys/version/$version\", { $version: version });\n        await this.baseApis.http.authedRequest<void>(Method.Delete, path, undefined, undefined, {\n            prefix: ClientPrefix.V3,\n        });\n    }\n\n    /**\n     * Check the server for an active key backup and\n     * if one is present and has a valid signature from\n     * one of the user's verified devices, start backing up\n     * to it.\n     */\n    public async checkAndStart(): Promise<IKeyBackupCheck | null> {\n        logger.log(\"Checking key backup status...\");\n        if (this.baseApis.isGuest()) {\n            logger.log(\"Skipping key backup check since user is guest\");\n            this.checkedForBackup = true;\n            return null;\n        }\n        let backupInfo: IKeyBackupInfo | undefined;\n        try {\n            backupInfo = (await this.baseApis.getKeyBackupVersion()) ?? undefined;\n        } catch (e) {\n            logger.log(\"Error checking for active key backup\", e);\n            if ((<HTTPError>e).httpStatus === 404) {\n                // 404 is returned when the key backup does not exist, so that\n                // counts as successfully checking.\n                this.checkedForBackup = true;\n            }\n            return null;\n        }\n        this.checkedForBackup = true;\n\n        const trustInfo = await this.isKeyBackupTrusted(backupInfo);\n\n        if (trustInfo.usable && !this.backupInfo) {\n            logger.log(`Found usable key backup v${backupInfo!.version}: enabling key backups`);\n            await this.enableKeyBackup(backupInfo!);\n        } else if (!trustInfo.usable && this.backupInfo) {\n            logger.log(\"No usable key backup: disabling key backup\");\n            this.disableKeyBackup();\n        } else if (!trustInfo.usable && !this.backupInfo) {\n            logger.log(\"No usable key backup: not enabling key backup\");\n        } else if (trustInfo.usable && this.backupInfo) {\n            // may not be the same version: if not, we should switch\n            if (backupInfo!.version !== this.backupInfo.version) {\n                logger.log(\n                    `On backup version ${this.backupInfo.version} but ` +\n                        `found version ${backupInfo!.version}: switching.`,\n                );\n                this.disableKeyBackup();\n                await this.enableKeyBackup(backupInfo!);\n                // We're now using a new backup, so schedule all the keys we have to be\n                // uploaded to the new backup. This is a bit of a workaround to upload\n                // keys to a new backup in *most* cases, but it won't cover all cases\n                // because we don't remember what backup version we uploaded keys to:\n                // see https://github.com/vector-im/element-web/issues/14833\n                await this.scheduleAllGroupSessionsForBackup();\n            } else {\n                logger.log(`Backup version ${backupInfo!.version} still current`);\n            }\n        }\n\n        return { backupInfo, trustInfo };\n    }\n\n    /**\n     * Forces a re-check of the key backup and enables/disables it\n     * as appropriate.\n     *\n     * @returns Object with backup info (as returned by\n     *     getKeyBackupVersion) in backupInfo and\n     *     trust information (as returned by isKeyBackupTrusted)\n     *     in trustInfo.\n     */\n    public async checkKeyBackup(): Promise<IKeyBackupCheck | null> {\n        this.checkedForBackup = false;\n        return this.checkAndStart();\n    }\n\n    /**\n     * Attempts to retrieve a session from a key backup, if enough time\n     * has elapsed since the last check for this session id.\n     */\n    public async queryKeyBackupRateLimited(\n        targetRoomId: string | undefined,\n        targetSessionId: string | undefined,\n    ): Promise<void> {\n        if (!this.backupInfo) {\n            return;\n        }\n\n        const now = new Date().getTime();\n        if (\n            !this.sessionLastCheckAttemptedTime[targetSessionId!] ||\n            now - this.sessionLastCheckAttemptedTime[targetSessionId!] > KEY_BACKUP_CHECK_RATE_LIMIT\n        ) {\n            this.sessionLastCheckAttemptedTime[targetSessionId!] = now;\n            await this.baseApis.restoreKeyBackupWithCache(targetRoomId!, targetSessionId!, this.backupInfo, {});\n        }\n    }\n\n    /**\n     * Check if the given backup info is trusted.\n     *\n     * @param backupInfo - key backup info dict from /room_keys/version\n     */\n    public async isKeyBackupTrusted(backupInfo?: IKeyBackupInfo): Promise<TrustInfo> {\n        const ret = {\n            usable: false,\n            trusted_locally: false,\n            sigs: [] as SigInfo[],\n        };\n\n        if (!backupInfo || !backupInfo.algorithm || !backupInfo.auth_data || !backupInfo.auth_data.signatures) {\n            logger.info(`Key backup is absent or missing required data: ${JSON.stringify(backupInfo)}`);\n            return ret;\n        }\n\n        const userId = this.baseApis.getUserId()!;\n        const privKey = await this.baseApis.crypto!.getSessionBackupPrivateKey();\n        if (privKey) {\n            let algorithm: BackupAlgorithm | null = null;\n            try {\n                algorithm = await BackupManager.makeAlgorithm(backupInfo, async () => privKey);\n\n                if (await algorithm.keyMatches(privKey)) {\n                    logger.info(\"Backup is trusted locally\");\n                    ret.trusted_locally = true;\n                }\n            } catch {\n                // do nothing -- if we have an error, then we don't mark it as\n                // locally trusted\n            } finally {\n                algorithm?.free();\n            }\n        }\n\n        const mySigs = backupInfo.auth_data.signatures[userId] || {};\n\n        for (const keyId of Object.keys(mySigs)) {\n            const keyIdParts = keyId.split(\":\");\n            if (keyIdParts[0] !== \"ed25519\") {\n                logger.log(\"Ignoring unknown signature type: \" + keyIdParts[0]);\n                continue;\n            }\n            // Could be a cross-signing master key, but just say this is the device\n            // ID for backwards compat\n            const sigInfo: SigInfo = { deviceId: keyIdParts[1] };\n\n            // first check to see if it's from our cross-signing key\n            const crossSigningId = this.baseApis.crypto!.crossSigningInfo.getId();\n            if (crossSigningId === sigInfo.deviceId) {\n                sigInfo.crossSigningId = true;\n                try {\n                    await verifySignature(\n                        this.baseApis.crypto!.olmDevice,\n                        backupInfo.auth_data,\n                        userId,\n                        sigInfo.deviceId,\n                        crossSigningId,\n                    );\n                    sigInfo.valid = true;\n                } catch (e) {\n                    logger.warn(\"Bad signature from cross signing key \" + crossSigningId, e);\n                    sigInfo.valid = false;\n                }\n                ret.sigs.push(sigInfo);\n                continue;\n            }\n\n            // Now look for a sig from a device\n            // At some point this can probably go away and we'll just support\n            // it being signed by the cross-signing master key\n            const device = this.baseApis.crypto!.deviceList.getStoredDevice(userId, sigInfo.deviceId);\n            if (device) {\n                sigInfo.device = device;\n                sigInfo.deviceTrust = this.baseApis.checkDeviceTrust(userId, sigInfo.deviceId);\n                try {\n                    await verifySignature(\n                        this.baseApis.crypto!.olmDevice,\n                        backupInfo.auth_data,\n                        userId,\n                        device.deviceId,\n                        device.getFingerprint(),\n                    );\n                    sigInfo.valid = true;\n                } catch (e) {\n                    logger.info(\n                        \"Bad signature from key ID \" +\n                            keyId +\n                            \" userID \" +\n                            this.baseApis.getUserId() +\n                            \" device ID \" +\n                            device.deviceId +\n                            \" fingerprint: \" +\n                            device.getFingerprint(),\n                        backupInfo.auth_data,\n                        e,\n                    );\n                    sigInfo.valid = false;\n                }\n            } else {\n                sigInfo.valid = null; // Can't determine validity because we don't have the signing device\n                logger.info(\"Ignoring signature from unknown key \" + keyId);\n            }\n            ret.sigs.push(sigInfo);\n        }\n\n        ret.usable = ret.sigs.some((s) => {\n            return s.valid && ((s.device && s.deviceTrust?.isVerified()) || s.crossSigningId);\n        });\n        return ret;\n    }\n\n    /**\n     * Schedules sending all keys waiting to be sent to the backup, if not already\n     * scheduled. Retries if necessary.\n     *\n     * @param maxDelay - Maximum delay to wait in ms. 0 means no delay.\n     */\n    public async scheduleKeyBackupSend(maxDelay = 10000): Promise<void> {\n        logger.debug(`Key backup: scheduleKeyBackupSend currentSending:${this.sendingBackups} delay:${maxDelay}`);\n        if (this.sendingBackups) return;\n\n        this.sendingBackups = true;\n\n        try {\n            // wait between 0 and `maxDelay` seconds, to avoid backup\n            // requests from different clients hitting the server all at\n            // the same time when a new key is sent\n            const delay = Math.random() * maxDelay;\n            await sleep(delay);\n            if (!this.clientRunning) {\n                this.sendingBackups = false;\n                return;\n            }\n            let numFailures = 0; // number of consecutive failures\n            for (;;) {\n                if (!this.algorithm) {\n                    return;\n                }\n                try {\n                    const numBackedUp = await this.backupPendingKeys(KEY_BACKUP_KEYS_PER_REQUEST);\n                    if (numBackedUp === 0) {\n                        // no sessions left needing backup: we're done\n                        this.sendingBackups = false;\n                        return;\n                    }\n                    numFailures = 0;\n                } catch (err) {\n                    numFailures++;\n                    logger.log(\"Key backup request failed\", err);\n                    if (err instanceof MatrixError) {\n                        const errCode = err.data.errcode;\n                        if (errCode == \"M_NOT_FOUND\" || errCode == \"M_WRONG_ROOM_KEYS_VERSION\") {\n                            // Set to false now as `checkKeyBackup` might schedule a backupsend before this one ends.\n                            this.sendingBackups = false;\n                            // Backup version has changed or this backup version\n                            // has been deleted\n                            this.baseApis.crypto!.emit(CryptoEvent.KeyBackupFailed, errCode);\n                            // Re-check key backup status on error, so we can be\n                            // sure to present the current situation when asked.\n                            // This call might restart the backup loop if new backup version is trusted\n                            await this.checkKeyBackup();\n                            return;\n                        }\n                    }\n                }\n                if (numFailures) {\n                    // exponential backoff if we have failures\n                    await sleep(1000 * Math.pow(2, Math.min(numFailures - 1, 4)));\n                }\n\n                if (!this.clientRunning) {\n                    logger.debug(\"Key backup send loop aborted, client stopped\");\n                    this.sendingBackups = false;\n                    return;\n                }\n            }\n        } catch (err) {\n            // No one actually checks errors on this promise, it's spawned internally.\n            // Just log, apps/client should use events to check status\n            logger.log(`Backup loop failed ${err}`);\n            this.sendingBackups = false;\n        }\n    }\n\n    /**\n     * Take some e2e keys waiting to be backed up and send them\n     * to the backup.\n     *\n     * @param limit - Maximum number of keys to back up\n     * @returns Number of sessions backed up\n     */\n    public async backupPendingKeys(limit: number): Promise<number> {\n        const sessions = await this.baseApis.crypto!.cryptoStore.getSessionsNeedingBackup(limit);\n        if (!sessions.length) {\n            return 0;\n        }\n\n        let remaining = await this.baseApis.crypto!.cryptoStore.countSessionsNeedingBackup();\n        this.baseApis.crypto!.emit(CryptoEvent.KeyBackupSessionsRemaining, remaining);\n\n        const rooms: IKeyBackup[\"rooms\"] = {};\n        for (const session of sessions) {\n            const roomId = session.sessionData!.room_id;\n            safeSet(rooms, roomId, rooms[roomId] || { sessions: {} });\n\n            const sessionData = this.baseApis.crypto!.olmDevice.exportInboundGroupSession(\n                session.senderKey,\n                session.sessionId,\n                session.sessionData!,\n            );\n            sessionData.algorithm = MEGOLM_ALGORITHM;\n\n            const forwardedCount = (sessionData.forwarding_curve25519_key_chain || []).length;\n\n            const userId = this.baseApis.crypto!.deviceList.getUserByIdentityKey(MEGOLM_ALGORITHM, session.senderKey);\n            const device =\n                this.baseApis.crypto!.deviceList.getDeviceByIdentityKey(MEGOLM_ALGORITHM, session.senderKey) ??\n                undefined;\n            const verified = this.baseApis.crypto!.checkDeviceInfoTrust(userId!, device).isVerified();\n\n            safeSet(rooms[roomId][\"sessions\"], session.sessionId, {\n                first_message_index: sessionData.first_known_index,\n                forwarded_count: forwardedCount,\n                is_verified: verified,\n                session_data: await this.algorithm!.encryptSession(sessionData),\n            });\n        }\n\n        await this.baseApis.sendKeyBackup(undefined, undefined, this.backupInfo!.version, { rooms });\n\n        await this.baseApis.crypto!.cryptoStore.unmarkSessionsNeedingBackup(sessions);\n        remaining = await this.baseApis.crypto!.cryptoStore.countSessionsNeedingBackup();\n        this.baseApis.crypto!.emit(CryptoEvent.KeyBackupSessionsRemaining, remaining);\n\n        return sessions.length;\n    }\n\n    public async backupGroupSession(senderKey: string, sessionId: string): Promise<void> {\n        await this.baseApis.crypto!.cryptoStore.markSessionsNeedingBackup([\n            {\n                senderKey: senderKey,\n                sessionId: sessionId,\n            },\n        ]);\n\n        if (this.backupInfo) {\n            // don't wait for this to complete: it will delay so\n            // happens in the background\n            this.scheduleKeyBackupSend();\n        }\n        // if this.backupInfo is not set, then the keys will be backed up when\n        // this.enableKeyBackup is called\n    }\n\n    /**\n     * Marks all group sessions as needing to be backed up and schedules them to\n     * upload in the background as soon as possible.\n     */\n    public async scheduleAllGroupSessionsForBackup(): Promise<void> {\n        await this.flagAllGroupSessionsForBackup();\n\n        // Schedule keys to upload in the background as soon as possible.\n        this.scheduleKeyBackupSend(0 /* maxDelay */);\n    }\n\n    /**\n     * Marks all group sessions as needing to be backed up without scheduling\n     * them to upload in the background.\n     * @returns Promise which resolves to the number of sessions now requiring a backup\n     *     (which will be equal to the number of sessions in the store).\n     */\n    public async flagAllGroupSessionsForBackup(): Promise<number> {\n        await this.baseApis.crypto!.cryptoStore.doTxn(\n            \"readwrite\",\n            [IndexedDBCryptoStore.STORE_INBOUND_GROUP_SESSIONS, IndexedDBCryptoStore.STORE_BACKUP],\n            (txn) => {\n                this.baseApis.crypto!.cryptoStore.getAllEndToEndInboundGroupSessions(txn, (session) => {\n                    if (session !== null) {\n                        this.baseApis.crypto!.cryptoStore.markSessionsNeedingBackup([session], txn);\n                    }\n                });\n            },\n        );\n\n        const remaining = await this.baseApis.crypto!.cryptoStore.countSessionsNeedingBackup();\n        this.baseApis.emit(CryptoEvent.KeyBackupSessionsRemaining, remaining);\n        return remaining;\n    }\n\n    /**\n     * Counts the number of end to end session keys that are waiting to be backed up\n     * @returns Promise which resolves to the number of sessions requiring backup\n     */\n    public countSessionsNeedingBackup(): Promise<number> {\n        return this.baseApis.crypto!.cryptoStore.countSessionsNeedingBackup();\n    }\n}\n\nexport class Curve25519 implements BackupAlgorithm {\n    public static algorithmName = \"m.megolm_backup.v1.curve25519-aes-sha2\";\n\n    public constructor(\n        public authData: ICurve25519AuthData,\n        private publicKey: any, // FIXME: PkEncryption\n        private getKey: () => Promise<Uint8Array>,\n    ) {}\n\n    public static async init(authData: AuthData, getKey: () => Promise<Uint8Array>): Promise<Curve25519> {\n        if (!authData || !(\"public_key\" in authData)) {\n            throw new Error(\"auth_data missing required information\");\n        }\n        const publicKey = new global.Olm.PkEncryption();\n        publicKey.set_recipient_key(authData.public_key);\n        return new Curve25519(authData as ICurve25519AuthData, publicKey, getKey);\n    }\n\n    public static async prepare(key?: string | Uint8Array | null): Promise<[Uint8Array, AuthData]> {\n        const decryption = new global.Olm.PkDecryption();\n        try {\n            const authData: Partial<ICurve25519AuthData> = {};\n            if (!key) {\n                authData.public_key = decryption.generate_key();\n            } else if (key instanceof Uint8Array) {\n                authData.public_key = decryption.init_with_private_key(key);\n            } else {\n                const derivation = await keyFromPassphrase(key);\n                authData.private_key_salt = derivation.salt;\n                authData.private_key_iterations = derivation.iterations;\n                authData.public_key = decryption.init_with_private_key(derivation.key);\n            }\n            const publicKey = new global.Olm.PkEncryption();\n            publicKey.set_recipient_key(authData.public_key);\n\n            return [decryption.get_private_key(), authData as AuthData];\n        } finally {\n            decryption.free();\n        }\n    }\n\n    public static checkBackupVersion(info: IKeyBackupInfo): void {\n        if (!(\"public_key\" in info.auth_data)) {\n            throw new Error(\"Invalid backup data returned\");\n        }\n    }\n\n    public get untrusted(): boolean {\n        return true;\n    }\n\n    public async encryptSession(data: Record<string, any>): Promise<Curve25519SessionData> {\n        const plainText: Record<string, any> = Object.assign({}, data);\n        delete plainText.session_id;\n        delete plainText.room_id;\n        delete plainText.first_known_index;\n        return this.publicKey.encrypt(JSON.stringify(plainText));\n    }\n\n    public async decryptSessions(\n        sessions: Record<string, IKeyBackupSession<Curve25519SessionData>>,\n    ): Promise<IMegolmSessionData[]> {\n        const privKey = await this.getKey();\n        const decryption = new global.Olm.PkDecryption();\n        try {\n            const backupPubKey = decryption.init_with_private_key(privKey);\n\n            if (backupPubKey !== this.authData.public_key) {\n                throw new MatrixError({ errcode: MatrixClient.RESTORE_BACKUP_ERROR_BAD_KEY });\n            }\n\n            const keys: IMegolmSessionData[] = [];\n\n            for (const [sessionId, sessionData] of Object.entries(sessions)) {\n                try {\n                    const decrypted = JSON.parse(\n                        decryption.decrypt(\n                            sessionData.session_data.ephemeral,\n                            sessionData.session_data.mac,\n                            sessionData.session_data.ciphertext,\n                        ),\n                    );\n                    decrypted.session_id = sessionId;\n                    keys.push(decrypted);\n                } catch (e) {\n                    logger.log(\"Failed to decrypt megolm session from backup\", e, sessionData);\n                }\n            }\n            return keys;\n        } finally {\n            decryption.free();\n        }\n    }\n\n    public async keyMatches(key: Uint8Array): Promise<boolean> {\n        const decryption = new global.Olm.PkDecryption();\n        let pubKey: string;\n        try {\n            pubKey = decryption.init_with_private_key(key);\n        } finally {\n            decryption.free();\n        }\n\n        return pubKey === this.authData.public_key;\n    }\n\n    public free(): void {\n        this.publicKey.free();\n    }\n}\n\nfunction randomBytes(size: number): Uint8Array {\n    const buf = new Uint8Array(size);\n    crypto.getRandomValues(buf);\n    return buf;\n}\n\nconst UNSTABLE_MSC3270_NAME = new UnstableValue(\n    \"m.megolm_backup.v1.aes-hmac-sha2\",\n    \"org.matrix.msc3270.v1.aes-hmac-sha2\",\n);\n\nexport class Aes256 implements BackupAlgorithm {\n    public static algorithmName = UNSTABLE_MSC3270_NAME.name;\n\n    public constructor(public readonly authData: IAes256AuthData, private readonly key: Uint8Array) {}\n\n    public static async init(authData: IAes256AuthData, getKey: () => Promise<Uint8Array>): Promise<Aes256> {\n        if (!authData) {\n            throw new Error(\"auth_data missing\");\n        }\n        const key = await getKey();\n        if (authData.mac) {\n            const { mac } = await calculateKeyCheck(key, authData.iv);\n            if (authData.mac.replace(/=+$/g, \"\") !== mac.replace(/=+/g, \"\")) {\n                throw new Error(\"Key does not match\");\n            }\n        }\n        return new Aes256(authData, key);\n    }\n\n    public static async prepare(key?: string | Uint8Array | null): Promise<[Uint8Array, AuthData]> {\n        let outKey: Uint8Array;\n        const authData: Partial<IAes256AuthData> = {};\n        if (!key) {\n            outKey = randomBytes(32);\n        } else if (key instanceof Uint8Array) {\n            outKey = new Uint8Array(key);\n        } else {\n            const derivation = await keyFromPassphrase(key);\n            authData.private_key_salt = derivation.salt;\n            authData.private_key_iterations = derivation.iterations;\n            outKey = derivation.key;\n        }\n\n        const { iv, mac } = await calculateKeyCheck(outKey);\n        authData.iv = iv;\n        authData.mac = mac;\n\n        return [outKey, authData as AuthData];\n    }\n\n    public static checkBackupVersion(info: IKeyBackupInfo): void {\n        if (!(\"iv\" in info.auth_data && \"mac\" in info.auth_data)) {\n            throw new Error(\"Invalid backup data returned\");\n        }\n    }\n\n    public get untrusted(): boolean {\n        return false;\n    }\n\n    public encryptSession(data: Record<string, any>): Promise<IEncryptedPayload> {\n        const plainText: Record<string, any> = Object.assign({}, data);\n        delete plainText.session_id;\n        delete plainText.room_id;\n        delete plainText.first_known_index;\n        return encryptAES(JSON.stringify(plainText), this.key, data.session_id);\n    }\n\n    public async decryptSessions(\n        sessions: Record<string, IKeyBackupSession<IEncryptedPayload>>,\n    ): Promise<IMegolmSessionData[]> {\n        const keys: IMegolmSessionData[] = [];\n\n        for (const [sessionId, sessionData] of Object.entries(sessions)) {\n            try {\n                const decrypted = JSON.parse(await decryptAES(sessionData.session_data, this.key, sessionId));\n                decrypted.session_id = sessionId;\n                keys.push(decrypted);\n            } catch (e) {\n                logger.log(\"Failed to decrypt megolm session from backup\", e, sessionData);\n            }\n        }\n        return keys;\n    }\n\n    public async keyMatches(key: Uint8Array): Promise<boolean> {\n        if (this.authData.mac) {\n            const { mac } = await calculateKeyCheck(key, this.authData.iv);\n            return this.authData.mac.replace(/=+$/g, \"\") === mac.replace(/=+/g, \"\");\n        } else {\n            // if we have no information, we have to assume the key is right\n            return true;\n        }\n    }\n\n    public free(): void {\n        this.key.fill(0);\n    }\n}\n\nexport const algorithmsByName: Record<string, BackupAlgorithmClass> = {\n    [Curve25519.algorithmName]: Curve25519,\n    [Aes256.algorithmName]: Aes256,\n};\n\nexport const DefaultAlgorithm: BackupAlgorithmClass = Curve25519;\n\n/**\n * Map a legacy {@link TrustInfo} into a new-style {@link BackupTrustInfo}.\n *\n * @param trustInfo - trustInfo to convert\n */\nexport function backupTrustInfoFromLegacyTrustInfo(trustInfo: TrustInfo): BackupTrustInfo {\n    return {\n        trusted: trustInfo.usable,\n        matchesDecryptionKey: trustInfo.trusted_locally ?? false,\n    };\n}\n\n/**\n * Implementation of {@link BackupDecryptor} for the libolm crypto backend.\n */\nexport class LibOlmBackupDecryptor implements BackupDecryptor {\n    private algorithm: BackupAlgorithm;\n    public readonly sourceTrusted: boolean;\n\n    public constructor(algorithm: BackupAlgorithm) {\n        this.algorithm = algorithm;\n        this.sourceTrusted = !algorithm.untrusted;\n    }\n\n    /**\n     * Implements {@link BackupDecryptor#free}\n     */\n    public free(): void {\n        this.algorithm.free();\n    }\n\n    /**\n     * Implements {@link BackupDecryptor#decryptSessions}\n     */\n    public async decryptSessions(\n        sessions: Record<string, IKeyBackupSession<Curve25519SessionData>>,\n    ): Promise<IMegolmSessionData[]> {\n        return await this.algorithm.decryptSessions(sessions);\n    }\n}\n"],"mappings":"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"}