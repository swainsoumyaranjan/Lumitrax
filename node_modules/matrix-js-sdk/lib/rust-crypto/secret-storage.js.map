{"version":3,"file":"secret-storage.js","names":["secretStorageContainsCrossSigningKeys","secretStorage","secretStorageCanAccessSecrets","secretNames","defaultKeyId","getDefaultKeyId","secretName","record","isStored"],"sources":["../../src/rust-crypto/secret-storage.ts"],"sourcesContent":["/*\nCopyright 2023 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport { ServerSideSecretStorage } from \"../secret-storage\";\n\n/**\n * Check that the private cross signing keys (master, self signing, user signing) are stored in the secret storage and encrypted with the default secret storage key.\n *\n * @param secretStorage - The secret store using account data\n * @returns True if the cross-signing keys are all stored and encrypted with the same secret storage key.\n *\n * @internal\n */\nexport async function secretStorageContainsCrossSigningKeys(secretStorage: ServerSideSecretStorage): Promise<boolean> {\n    return secretStorageCanAccessSecrets(secretStorage, [\n        \"m.cross_signing.master\",\n        \"m.cross_signing.user_signing\",\n        \"m.cross_signing.self_signing\",\n    ]);\n}\n\n/**\n *\n * Check that the secret storage can access the given secrets using the default key.\n *\n * @param secretStorage - The secret store using account data\n * @param secretNames - The secret names to check\n * @returns True if all the given secrets are accessible and encrypted with the given key.\n *\n * @internal\n */\nexport async function secretStorageCanAccessSecrets(\n    secretStorage: ServerSideSecretStorage,\n    secretNames: string[],\n): Promise<boolean> {\n    const defaultKeyId = await secretStorage.getDefaultKeyId();\n    if (!defaultKeyId) return false;\n\n    for (const secretName of secretNames) {\n        // check which keys this particular secret is encrypted with\n        const record = (await secretStorage.isStored(secretName)) || {};\n        // if it's not encrypted with the right key, there is no point continuing\n        if (!(defaultKeyId in record)) return false;\n    }\n\n    return true;\n}\n"],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeA,qCAAqCA,CAACC,aAAsC,EAAoB;EAClH,OAAOC,6BAA6B,CAACD,aAAa,EAAE,CAChD,wBAAwB,EACxB,8BAA8B,EAC9B,8BAA8B,CACjC,CAAC;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,eAAeC,6BAA6BA,CAC/CD,aAAsC,EACtCE,WAAqB,EACL;EAChB,MAAMC,YAAY,GAAG,MAAMH,aAAa,CAACI,eAAe,CAAC,CAAC;EAC1D,IAAI,CAACD,YAAY,EAAE,OAAO,KAAK;EAE/B,KAAK,MAAME,UAAU,IAAIH,WAAW,EAAE;IAClC;IACA,MAAMI,MAAM,GAAG,CAAC,MAAMN,aAAa,CAACO,QAAQ,CAACF,UAAU,CAAC,KAAK,CAAC,CAAC;IAC/D;IACA,IAAI,EAAEF,YAAY,IAAIG,MAAM,CAAC,EAAE,OAAO,KAAK;EAC/C;EAEA,OAAO,IAAI;AACf"}