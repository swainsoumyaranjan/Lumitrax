import { OlmMachine } from "@matrix-org/matrix-sdk-crypto-wasm";
import * as RustSdkCryptoJs from "@matrix-org/matrix-sdk-crypto-wasm";
import { BackupTrustInfo, KeyBackupCheck, KeyBackupInfo, KeyBackupSession, Curve25519SessionData } from "../crypto-api/keybackup";
import { IHttpOpts, MatrixHttpApi } from "../http-api";
import { CryptoEvent, IMegolmSessionData } from "../crypto";
import { TypedEventEmitter } from "../models/typed-event-emitter";
import { OutgoingRequestProcessor } from "./OutgoingRequestProcessor";
import { BackupDecryptor } from "../common-crypto/CryptoBackend";
import { IEncryptedPayload } from "../crypto/aes";
import { ImportRoomKeysOpts } from "../crypto-api";
/** Authentification of the backup info, depends on algorithm */
type AuthData = KeyBackupInfo["auth_data"];
/**
 * Holds information of a created keybackup.
 * Useful to get the generated private key material and save it securely somewhere.
 */
interface KeyBackupCreationInfo {
    version: string;
    algorithm: string;
    authData: AuthData;
    decryptionKey: RustSdkCryptoJs.BackupDecryptionKey;
}
/**
 * @internal
 */
export declare class RustBackupManager extends TypedEventEmitter<RustBackupCryptoEvents, RustBackupCryptoEventMap> {
    private readonly olmMachine;
    private readonly http;
    private readonly outgoingRequestProcessor;
    /** Have we checked if there is a backup on the server which we can use */
    private checkedForBackup;
    private activeBackupVersion;
    private stopped;
    /** whether {@link backupKeysLoop} is currently running */
    private backupKeysLoopRunning;
    constructor(olmMachine: OlmMachine, http: MatrixHttpApi<IHttpOpts & {
        onlyData: true;
    }>, outgoingRequestProcessor: OutgoingRequestProcessor);
    /**
     * Tells the RustBackupManager to stop.
     * The RustBackupManager is scheduling background uploads of keys to the backup, this
     * call allows to cancel the process when the client is stoppped.
     */
    stop(): void;
    /**
     * Get the backup version we are currently backing up to, if any
     */
    getActiveBackupVersion(): Promise<string | null>;
    /**
     * Determine if a key backup can be trusted.
     *
     * @param info - key backup info dict from {@link MatrixClient#getKeyBackupVersion}.
     */
    isKeyBackupTrusted(info: KeyBackupInfo): Promise<BackupTrustInfo>;
    /**
     * Re-check the key backup and enable/disable it as appropriate.
     *
     * @param force - whether we should force a re-check even if one has already happened.
     */
    checkKeyBackupAndEnable(force: boolean): Promise<KeyBackupCheck | null>;
    /**
     * Handles a backup secret received event and store it if it matches the current backup version.
     *
     * @param secret - The secret as received from a `m.secert.send` event for secret `m.megolm_backup.v1`.
     * @returns true if the secret is valid and has been stored, false otherwise.
     */
    handleBackupSecretReceived(secret: string): Promise<boolean>;
    saveBackupDecryptionKey(backupDecryptionKey: RustSdkCryptoJs.BackupDecryptionKey, version: string): Promise<void>;
    /**
     * Import a list of room keys previously exported by exportRoomKeys
     *
     * @param keys - a list of session export objects
     * @param opts - options object
     * @returns a promise which resolves once the keys have been imported
     */
    importRoomKeys(keys: IMegolmSessionData[], opts?: ImportRoomKeysOpts): Promise<void>;
    /**
     * Implementation of {@link CryptoBackend#importBackedUpRoomKeys}.
     */
    importBackedUpRoomKeys(keys: IMegolmSessionData[], opts?: ImportRoomKeysOpts): Promise<void>;
    private keyBackupCheckInProgress;
    /** Helper for `checkKeyBackup` */
    private doCheckKeyBackup;
    private enableKeyBackup;
    /**
     * Restart the backup key loop if there is an active trusted backup.
     * Doesn't try to check the backup server side. To be called when a new
     * megolm key is known locally.
     */
    maybeUploadKey(): Promise<void>;
    private disableKeyBackup;
    private backupKeysLoop;
    /**
     * Get information about the current key backup from the server
     *
     * @returns Information object from API or null if there is no active backup.
     */
    requestKeyBackupVersion(): Promise<KeyBackupInfo | null>;
    /**
     * Creates a new key backup by generating a new random private key.
     *
     * If there is an existing backup server side it will be deleted and replaced
     * by the new one.
     *
     * @param signObject - Method that should sign the backup with existing device and
     * existing identity.
     * @returns a KeyBackupCreationInfo - All information related to the backup.
     */
    setupKeyBackup(signObject: (authData: AuthData) => Promise<void>): Promise<KeyBackupCreationInfo>;
    /**
     * Deletes all key backups.
     *
     * Will call the API to delete active backup until there is no more present.
     */
    deleteAllKeyBackupVersions(): Promise<void>;
    /**
     * Deletes the given key backup.
     *
     * @param version - The backup version to delete.
     */
    deleteKeyBackupVersion(version: string): Promise<void>;
    /**
     * Creates a new backup decryptor for the given private key.
     * @param decryptionKey - The private key to use for decryption.
     */
    createBackupDecryptor(decryptionKey: RustSdkCryptoJs.BackupDecryptionKey): BackupDecryptor;
}
/**
 * Implementation of {@link BackupDecryptor} for the rust crypto backend.
 */
export declare class RustBackupDecryptor implements BackupDecryptor {
    private decryptionKey;
    sourceTrusted: boolean;
    constructor(decryptionKey: RustSdkCryptoJs.BackupDecryptionKey);
    /**
     * Implements {@link BackupDecryptor#decryptSessions}
     */
    decryptSessions(ciphertexts: Record<string, KeyBackupSession<Curve25519SessionData | IEncryptedPayload>>): Promise<IMegolmSessionData[]>;
    /**
     * Implements {@link BackupDecryptor#free}
     */
    free(): void;
}
export type RustBackupCryptoEvents = CryptoEvent.KeyBackupStatus | CryptoEvent.KeyBackupSessionsRemaining | CryptoEvent.KeyBackupFailed | CryptoEvent.KeyBackupDecryptionKeyCached;
export type RustBackupCryptoEventMap = {
    [CryptoEvent.KeyBackupStatus]: (enabled: boolean) => void;
    [CryptoEvent.KeyBackupSessionsRemaining]: (remaining: number) => void;
    [CryptoEvent.KeyBackupFailed]: (errCode: string) => void;
    [CryptoEvent.KeyBackupDecryptionKeyCached]: (version: string) => void;
};
export {};
//# sourceMappingURL=backup.d.ts.map