{"version":3,"file":"embedded.js","names":["_matrixWidgetApi","require","_event","_event2","_logger","_client","_sync","_slidingSyncSdk","_user","_utils","RoomWidgetClient","MatrixClient","constructor","widgetApi","capabilities","roomId","opts","_capabilities$sendEve","_capabilities$receive","_capabilities$sendSta","_capabilities$receive2","_capabilities$sendEve2","_capabilities$receive3","_capabilities$sendSta2","_capabilities$receive4","_capabilities$sendToD","_capabilities$receive5","_defineProperty2","default","ev","preventDefault","detail","data","room_id","event","MatrixEvent","syncApi","injectRoomEvents","room","emit","ClientEvent","Event","setSyncState","SyncState","Syncing","logger","info","getId","getType","getStateKey","event_id","eventId","ack","type","sender","content","encrypted","makeEncrypted","EventType","RoomMessageEncrypted","ToDeviceEvent","widgetApiReady","Promise","resolve","once","sendEvent","length","receiveEvent","sendMessage","Array","isArray","receiveMessage","sendState","receiveState","requestCapabilityForRoomTimeline","forEach","eventType","requestCapabilityToSendEvent","requestCapabilityToReceiveEvent","requestCapabilityToSendMessage","msgType","requestCapabilityToReceiveMessage","stateKey","requestCapabilityToSendState","requestCapabilityToReceiveState","sendToDevice","requestCapabilityToSendToDevice","receiveToDevice","requestCapabilityToReceiveToDevice","turnServers","requestCapability","MatrixCapabilities","MSC3846TurnServers","on","WidgetApiToWidgetAction","SendEvent","onEvent","SendToDevice","onToDevice","start","sendContentLoaded","startClient","_this$capabilities$re","_this$capabilities$re2","lifecycle","AbortController","userId","getUserId","store","storeUser","User","slidingSync","SlidingSyncSdk","buildSyncApiOptions","SyncApi","createRoom","storeRoom","all","map","rawEvents","readStateEvents","undefined","events","rawEvent","matrixRTC","watchTurnServers","stopClient","off","abort","joinRoom","roomIdOrAlias","Error","encryptAndSendEvent","response","sendRoomEvent","getContent","e","updatePendingEventStatus","EventStatus","NOT_SENT","updatePendingEvent","SENT","sendStateEvent","contentMap","recursiveMapToObject","getOpenIdToken","token","requestOpenIDConnectToken","access_token","expires_in","matrix_server_name","token_type","queueToDevice","batch","MapWithDefault","Map","deviceId","payload","getOrCreate","set","encryptAndSendToDevices","userDeviceInfoArr","deviceInfo","checkTurnServers","getSyncState","syncState","state","oldState","Sync","transport","reply","servers","getTurnServers","onClientStopped","return","signal","addEventListener","server","urls","uris","username","credential","password","TurnServers","log","warn","removeEventListener","exports"],"sources":["../src/embedded.ts"],"sourcesContent":["/*\nCopyright 2022 The Matrix.org Foundation C.I.C.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\nimport {\n    WidgetApi,\n    WidgetApiToWidgetAction,\n    MatrixCapabilities,\n    IWidgetApiRequest,\n    IWidgetApiAcknowledgeResponseData,\n    ISendEventToWidgetActionRequest,\n    ISendToDeviceToWidgetActionRequest,\n    ISendEventFromWidgetResponseData,\n} from \"matrix-widget-api\";\n\nimport { MatrixEvent, IEvent, IContent, EventStatus } from \"./models/event\";\nimport { ISendEventResponse } from \"./@types/requests\";\nimport { EventType } from \"./@types/event\";\nimport { logger } from \"./logger\";\nimport {\n    MatrixClient,\n    ClientEvent,\n    IMatrixClientCreateOpts,\n    IStartClientOpts,\n    SendToDeviceContentMap,\n    IOpenIDToken,\n} from \"./client\";\nimport { SyncApi, SyncState } from \"./sync\";\nimport { SlidingSyncSdk } from \"./sliding-sync-sdk\";\nimport { User } from \"./models/user\";\nimport { Room } from \"./models/room\";\nimport { ToDeviceBatch, ToDevicePayload } from \"./models/ToDeviceMessage\";\nimport { DeviceInfo } from \"./crypto/deviceinfo\";\nimport { IOlmDevice } from \"./crypto/algorithms/megolm\";\nimport { MapWithDefault, recursiveMapToObject } from \"./utils\";\n\ninterface IStateEventRequest {\n    eventType: string;\n    stateKey?: string;\n}\n\nexport interface ICapabilities {\n    /**\n     * Event types that this client expects to send.\n     */\n    sendEvent?: string[];\n    /**\n     * Event types that this client expects to receive.\n     */\n    receiveEvent?: string[];\n\n    /**\n     * Message types that this client expects to send, or true for all message\n     * types.\n     */\n    sendMessage?: string[] | true;\n    /**\n     * Message types that this client expects to receive, or true for all\n     * message types.\n     */\n    receiveMessage?: string[] | true;\n\n    /**\n     * Types of state events that this client expects to send.\n     */\n    sendState?: IStateEventRequest[];\n    /**\n     * Types of state events that this client expects to receive.\n     */\n    receiveState?: IStateEventRequest[];\n\n    /**\n     * To-device event types that this client expects to send.\n     */\n    sendToDevice?: string[];\n    /**\n     * To-device event types that this client expects to receive.\n     */\n    receiveToDevice?: string[];\n\n    /**\n     * Whether this client needs access to TURN servers.\n     * @defaultValue false\n     */\n    turnServers?: boolean;\n}\n\n/**\n * A MatrixClient that routes its requests through the widget API instead of the\n * real CS API.\n * @experimental This class is considered unstable!\n */\nexport class RoomWidgetClient extends MatrixClient {\n    private room?: Room;\n    private readonly widgetApiReady: Promise<void>;\n    private lifecycle?: AbortController;\n    private syncState: SyncState | null = null;\n\n    public constructor(\n        private readonly widgetApi: WidgetApi,\n        private readonly capabilities: ICapabilities,\n        private readonly roomId: string,\n        opts: IMatrixClientCreateOpts,\n    ) {\n        super(opts);\n\n        this.widgetApiReady = new Promise<void>((resolve) => this.widgetApi.once(\"ready\", resolve));\n\n        // Request capabilities for the functionality this client needs to support\n        if (\n            capabilities.sendEvent?.length ||\n            capabilities.receiveEvent?.length ||\n            capabilities.sendMessage === true ||\n            (Array.isArray(capabilities.sendMessage) && capabilities.sendMessage.length) ||\n            capabilities.receiveMessage === true ||\n            (Array.isArray(capabilities.receiveMessage) && capabilities.receiveMessage.length) ||\n            capabilities.sendState?.length ||\n            capabilities.receiveState?.length\n        ) {\n            widgetApi.requestCapabilityForRoomTimeline(roomId);\n        }\n        capabilities.sendEvent?.forEach((eventType) => widgetApi.requestCapabilityToSendEvent(eventType));\n        capabilities.receiveEvent?.forEach((eventType) => widgetApi.requestCapabilityToReceiveEvent(eventType));\n        if (capabilities.sendMessage === true) {\n            widgetApi.requestCapabilityToSendMessage();\n        } else if (Array.isArray(capabilities.sendMessage)) {\n            capabilities.sendMessage.forEach((msgType) => widgetApi.requestCapabilityToSendMessage(msgType));\n        }\n        if (capabilities.receiveMessage === true) {\n            widgetApi.requestCapabilityToReceiveMessage();\n        } else if (Array.isArray(capabilities.receiveMessage)) {\n            capabilities.receiveMessage.forEach((msgType) => widgetApi.requestCapabilityToReceiveMessage(msgType));\n        }\n        capabilities.sendState?.forEach(({ eventType, stateKey }) =>\n            widgetApi.requestCapabilityToSendState(eventType, stateKey),\n        );\n        capabilities.receiveState?.forEach(({ eventType, stateKey }) =>\n            widgetApi.requestCapabilityToReceiveState(eventType, stateKey),\n        );\n        capabilities.sendToDevice?.forEach((eventType) => widgetApi.requestCapabilityToSendToDevice(eventType));\n        capabilities.receiveToDevice?.forEach((eventType) => widgetApi.requestCapabilityToReceiveToDevice(eventType));\n        if (capabilities.turnServers) {\n            widgetApi.requestCapability(MatrixCapabilities.MSC3846TurnServers);\n        }\n\n        widgetApi.on(`action:${WidgetApiToWidgetAction.SendEvent}`, this.onEvent);\n        widgetApi.on(`action:${WidgetApiToWidgetAction.SendToDevice}`, this.onToDevice);\n\n        // Open communication with the host\n        widgetApi.start();\n        // Send a content loaded event now we've started the widget API\n        // Note that element-web currently does not use waitForIFrameLoad=false and so\n        // does *not* (yes, that is the right way around) wait for this event. Let's\n        // start sending this, then once this has rolled out, we can change element-web to\n        // use waitForIFrameLoad=false and have a widget API that's less racy.\n        widgetApi.sendContentLoaded();\n    }\n\n    public async startClient(opts: IStartClientOpts = {}): Promise<void> {\n        this.lifecycle = new AbortController();\n\n        // Create our own user object artificially (instead of waiting for sync)\n        // so it's always available, even if the user is not in any rooms etc.\n        const userId = this.getUserId();\n        if (userId) {\n            this.store.storeUser(new User(userId));\n        }\n\n        // Even though we have no access token and cannot sync, the sync class\n        // still has some valuable helper methods that we make use of, so we\n        // instantiate it anyways\n        if (opts.slidingSync) {\n            this.syncApi = new SlidingSyncSdk(opts.slidingSync, this, opts, this.buildSyncApiOptions());\n        } else {\n            this.syncApi = new SyncApi(this, opts, this.buildSyncApiOptions());\n        }\n\n        this.room = this.syncApi.createRoom(this.roomId);\n        this.store.storeRoom(this.room);\n\n        await this.widgetApiReady;\n\n        // Backfill the requested events\n        // We only get the most recent event for every type + state key combo,\n        // so it doesn't really matter what order we inject them in\n        await Promise.all(\n            this.capabilities.receiveState?.map(async ({ eventType, stateKey }) => {\n                const rawEvents = await this.widgetApi.readStateEvents(eventType, undefined, stateKey, [this.roomId]);\n                const events = rawEvents.map((rawEvent) => new MatrixEvent(rawEvent as Partial<IEvent>));\n\n                await this.syncApi!.injectRoomEvents(this.room!, [], events);\n                events.forEach((event) => {\n                    this.emit(ClientEvent.Event, event);\n                    logger.info(`Backfilled event ${event.getId()} ${event.getType()} ${event.getStateKey()}`);\n                });\n            }) ?? [],\n        );\n        this.setSyncState(SyncState.Syncing);\n        logger.info(\"Finished backfilling events\");\n\n        this.matrixRTC.start();\n\n        // Watch for TURN servers, if requested\n        if (this.capabilities.turnServers) this.watchTurnServers();\n    }\n\n    public stopClient(): void {\n        this.widgetApi.off(`action:${WidgetApiToWidgetAction.SendEvent}`, this.onEvent);\n        this.widgetApi.off(`action:${WidgetApiToWidgetAction.SendToDevice}`, this.onToDevice);\n\n        super.stopClient();\n        this.lifecycle!.abort(); // Signal to other async tasks that the client has stopped\n    }\n\n    public async joinRoom(roomIdOrAlias: string): Promise<Room> {\n        if (roomIdOrAlias === this.roomId) return this.room!;\n        throw new Error(`Unknown room: ${roomIdOrAlias}`);\n    }\n\n    protected async encryptAndSendEvent(room: Room, event: MatrixEvent): Promise<ISendEventResponse> {\n        let response: ISendEventFromWidgetResponseData;\n        try {\n            response = await this.widgetApi.sendRoomEvent(event.getType(), event.getContent(), room.roomId);\n        } catch (e) {\n            this.updatePendingEventStatus(room, event, EventStatus.NOT_SENT);\n            throw e;\n        }\n\n        room.updatePendingEvent(event, EventStatus.SENT, response.event_id);\n        return { event_id: response.event_id };\n    }\n\n    public async sendStateEvent(\n        roomId: string,\n        eventType: string,\n        content: any,\n        stateKey = \"\",\n    ): Promise<ISendEventResponse> {\n        return await this.widgetApi.sendStateEvent(eventType, stateKey, content, roomId);\n    }\n\n    public async sendToDevice(eventType: string, contentMap: SendToDeviceContentMap): Promise<{}> {\n        await this.widgetApi.sendToDevice(eventType, false, recursiveMapToObject(contentMap));\n        return {};\n    }\n\n    public async getOpenIdToken(): Promise<IOpenIDToken> {\n        const token = await this.widgetApi.requestOpenIDConnectToken();\n        // the IOpenIDCredentials from the widget-api and IOpenIDToken form the matrix-js-sdk are compatible.\n        // we still recreate the token to make this transparent and catch'able by the linter in case the types change in the future.\n        return <IOpenIDToken>{\n            access_token: token.access_token,\n            expires_in: token.expires_in,\n            matrix_server_name: token.matrix_server_name,\n            token_type: token.token_type,\n        };\n    }\n\n    public async queueToDevice({ eventType, batch }: ToDeviceBatch): Promise<void> {\n        // map: user Id → device Id → payload\n        const contentMap: MapWithDefault<string, Map<string, ToDevicePayload>> = new MapWithDefault(() => new Map());\n        for (const { userId, deviceId, payload } of batch) {\n            contentMap.getOrCreate(userId).set(deviceId, payload);\n        }\n\n        await this.widgetApi.sendToDevice(eventType, false, recursiveMapToObject(contentMap));\n    }\n\n    public async encryptAndSendToDevices(userDeviceInfoArr: IOlmDevice<DeviceInfo>[], payload: object): Promise<void> {\n        // map: user Id → device Id → payload\n        const contentMap: MapWithDefault<string, Map<string, object>> = new MapWithDefault(() => new Map());\n        for (const {\n            userId,\n            deviceInfo: { deviceId },\n        } of userDeviceInfoArr) {\n            contentMap.getOrCreate(userId).set(deviceId, payload);\n        }\n\n        await this.widgetApi.sendToDevice((payload as { type: string }).type, true, recursiveMapToObject(contentMap));\n    }\n\n    // Overridden since we get TURN servers automatically over the widget API,\n    // and this method would otherwise complain about missing an access token\n    public async checkTurnServers(): Promise<boolean> {\n        return this.turnServers.length > 0;\n    }\n\n    // Overridden since we 'sync' manually without the sync API\n    public getSyncState(): SyncState | null {\n        return this.syncState;\n    }\n\n    private setSyncState(state: SyncState): void {\n        const oldState = this.syncState;\n        this.syncState = state;\n        this.emit(ClientEvent.Sync, state, oldState);\n    }\n\n    private async ack(ev: CustomEvent<IWidgetApiRequest>): Promise<void> {\n        await this.widgetApi.transport.reply<IWidgetApiAcknowledgeResponseData>(ev.detail, {});\n    }\n\n    private onEvent = async (ev: CustomEvent<ISendEventToWidgetActionRequest>): Promise<void> => {\n        ev.preventDefault();\n\n        // Verify the room ID matches, since it's possible for the client to\n        // send us events from other rooms if this widget is always on screen\n        if (ev.detail.data.room_id === this.roomId) {\n            const event = new MatrixEvent(ev.detail.data as Partial<IEvent>);\n            await this.syncApi!.injectRoomEvents(this.room!, [], [event]);\n            this.emit(ClientEvent.Event, event);\n            this.setSyncState(SyncState.Syncing);\n            logger.info(`Received event ${event.getId()} ${event.getType()} ${event.getStateKey()}`);\n        } else {\n            const { event_id: eventId, room_id: roomId } = ev.detail.data;\n            logger.info(`Received event ${eventId} for a different room ${roomId}; discarding`);\n        }\n\n        await this.ack(ev);\n    };\n\n    private onToDevice = async (ev: CustomEvent<ISendToDeviceToWidgetActionRequest>): Promise<void> => {\n        ev.preventDefault();\n\n        const event = new MatrixEvent({\n            type: ev.detail.data.type,\n            sender: ev.detail.data.sender,\n            content: ev.detail.data.content as IContent,\n        });\n        // Mark the event as encrypted if it was, using fake contents and keys since those are unknown to us\n        if (ev.detail.data.encrypted) event.makeEncrypted(EventType.RoomMessageEncrypted, {}, \"\", \"\");\n\n        this.emit(ClientEvent.ToDeviceEvent, event);\n        this.setSyncState(SyncState.Syncing);\n        await this.ack(ev);\n    };\n\n    private async watchTurnServers(): Promise<void> {\n        const servers = this.widgetApi.getTurnServers();\n        const onClientStopped = (): void => {\n            servers.return(undefined);\n        };\n        this.lifecycle!.signal.addEventListener(\"abort\", onClientStopped);\n\n        try {\n            for await (const server of servers) {\n                this.turnServers = [\n                    {\n                        urls: server.uris,\n                        username: server.username,\n                        credential: server.password,\n                    },\n                ];\n                this.emit(ClientEvent.TurnServers, this.turnServers);\n                logger.log(`Received TURN server: ${server.uris}`);\n            }\n        } catch (e) {\n            logger.warn(\"Error watching TURN servers\", e);\n        } finally {\n            this.lifecycle!.signal.removeEventListener(\"abort\", onClientStopped);\n        }\n    }\n}\n"],"mappings":"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"}