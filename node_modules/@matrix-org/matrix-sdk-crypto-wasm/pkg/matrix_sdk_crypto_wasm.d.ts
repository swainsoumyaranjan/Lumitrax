/* tslint:disable */
/* eslint-disable */
/**
* Get the versions of the Rust libraries we are using.
* @returns {Versions}
*/
export function getVersions(): Versions;
/**
* Run some stuff when the Wasm module is instantiated.
*
* Right now, it does the following:
*
* * Redirect Rust panics to JavaScript console.
*/
export function start(): void;
/**
* Who can see a room's history.
*/
export enum HistoryVisibility {
/**
* Previous events are accessible to newly joined members from
* the point they were invited onwards.
*
* Events stop being accessible when the member's state changes
* to something other than *invite* or *join*.
*/
  Invited = 0,
/**
* Previous events are accessible to newly joined members from
* the point they joined the room onwards.
*
* Events stop being accessible when the member's state changes
* to something other than *join*.
*/
  Joined = 1,
/**
* Previous events are always accessible to newly joined members.
*
* All events in the room are accessible, even those sent when
* the member was not a part of the room.
*/
  Shared = 2,
/**
* All events while this is the `HistoryVisibility` value may be
* shared by any participating homeserver with anyone, regardless
* of whether they have ever joined the room.
*/
  WorldReadable = 3,
}
/**
* Represent the type of a request.
*/
export enum RequestType {
/**
* Represents a `KeysUploadRequest`.
*/
  KeysUpload = 0,
/**
* Represents a `KeysQueryRequest`.
*/
  KeysQuery = 1,
/**
* Represents a `KeysClaimRequest`.
*/
  KeysClaim = 2,
/**
* Represents a `ToDeviceRequest`.
*/
  ToDevice = 3,
/**
* Represents a `SignatureUploadRequest`.
*/
  SignatureUpload = 4,
/**
* Represents a `RoomMessageRequest`.
*/
  RoomMessage = 5,
/**
* Represents a `KeysBackupRequest`.
*/
  KeysBackup = 6,
}
/**
* The result of a signature check.
*/
export enum SignatureState {
/**
* The signature is missing.
*/
  Missing = 0,
/**
* The signature is invalid.
*/
  Invalid = 1,
/**
* The signature is valid but the device or user identity that created the
* signature is not trusted.
*/
  ValidButNotTrusted = 2,
/**
* The signature is valid and the device or user identity that created the
* signature is trusted.
*/
  ValidAndTrusted = 3,
}
/**
* List of available verification methods.
*/
export enum VerificationMethod {
/**
* The `m.sas.v1` verification method.
*
* SAS means Short Authentication String.
*/
  SasV1 = 0,
/**
* The `m.qr_code.scan.v1` verification method.
*/
  QrCodeScanV1 = 1,
/**
* The `m.qr_code.show.v1` verification method.
*/
  QrCodeShowV1 = 2,
/**
* The `m.reciprocate.v1` verification method.
*/
  ReciprocateV1 = 3,
}
/**
* List of `Qr` states
*/
export enum QrState {
/**
* We have received the other device's details (from the
* `m.key.verification.request` or `m.key.verification.ready`) and
* established the shared secret, so can
* display the QR code.
*/
  Created = 0,
/**
* The other side has scanned our QR code and sent an
* `m.key.verification.start` message with `method: m.reciprocate.v1` with
* matching shared secret.
*/
  Scanned = 1,
/**
* Our user has confirmed that the other device scanned successfully. We
* have sent an `m.key.verification.done`.
*/
  Confirmed = 2,
/**
* We have scanned the other side's QR code and are able to send a
* `m.key.verification.start` message with `method: m.reciprocate.v1`.
*
* Call `Qr::reciprocate` to build the start message.
*
* Note that, despite the name of this state, we have not necessarily
* yet sent the `m.reciprocate.v1` message.
*/
  Reciprocated = 3,
/**
* Verification complete: we have received an `m.key.verification.done`
* from the other side.
*/
  Done = 4,
/**
* Verification cancelled or failed.
*/
  Cancelled = 5,
}
/**
* List of VerificationRequestState phases
*/
export enum VerificationRequestPhase {
/**
* The verification request has been newly created by us.
*/
  Created = 0,
/**
* The verification request was received from the other party.
*/
  Requested = 1,
/**
* The verification request is ready to start a verification flow.
*/
  Ready = 2,
/**
* The verification request has transitioned into a concrete verification
* flow. For example it transitioned into the emoji based SAS
* verification.
*/
  Transitioned = 3,
/**
* The verification flow that was started with this request has finished.
*/
  Done = 4,
/**
* The verification process has been cancelled.
*/
  Cancelled = 5,
}
/**
* An encryption algorithm to be used to encrypt messages sent to a
* room.
*/
export enum EncryptionAlgorithm {
/**
* Olm version 1 using Curve25519, AES-256, and SHA-256.
*/
  OlmV1Curve25519AesSha2 = 0,
/**
* Megolm version 1 using AES-256 and SHA-256.
*/
  MegolmV1AesSha2 = 1,
}
/**
* Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
* for more info.
*/
export enum ShieldColor {
/**
* Important warning
*/
  Red = 0,
/**
* Low warning
*/
  Grey = 1,
/**
* No warning
*/
  None = 2,
}
/**
* Decryption error codes
*/
export enum DecryptionErrorCode {
/**
* The room key is not known
*/
  MissingRoomKey = 0,
/**
* The room key is known but ratcheted
*/
  UnknownMessageIndex = 1,
/**
* Decryption failed because of a mismatch between the identity keys of the
* device we received the room key from and the identity keys recorded in
* the plaintext of the room key to-device message.
*/
  MismatchedIdentityKeys = 2,
/**
* Other failuer
*/
  UnableToDecrypt = 3,
}
/**
* The basic key algorithm names in the specification.
*/
export enum DeviceKeyAlgorithmName {
/**
* The Ed25519 signature algorithm.
*/
  Ed25519 = 0,
/**
* The Curve25519 ECDH algorithm.
*/
  Curve25519 = 1,
/**
* The Curve25519 ECDH algorithm, but the key also contains
* signatures.
*/
  SignedCurve25519 = 2,
/**
* An unknown device key algorithm.
*/
  Unknown = 3,
}
/**
* The local trust state of a device.
*/
export enum LocalTrust {
/**
* The device has been verified and is trusted.
*/
  Verified = 0,
/**
* The device been blacklisted from communicating.
*/
  BlackListed = 1,
/**
* The trust state of the device is being ignored.
*/
  Ignored = 2,
/**
* The trust state is unset.
*/
  Unset = 3,
}
/**
* Logger level.
*/
export enum LoggerLevel {
/**
* `TRACE` level.
*
* Designate very low priority, often extremely verbose,
* information.
*/
  Trace = 0,
/**
* `DEBUG` level.
*
* Designate lower priority information.
*/
  Debug = 1,
/**
* `INFO` level.
*
* Designate useful information.
*/
  Info = 2,
/**
* `WARN` level.
*
* Designate hazardous situations.
*/
  Warn = 3,
/**
* `ERROR` level.
*
* Designate very serious errors.
*/
  Error = 4,
}
/**
* An enum over the different key types a device can have.
*
* Currently devices have a curve25519 and ed25519 keypair. The keys
* transport format is a base64 encoded string, any unknown key type
* will be left as such a string.
*/
export enum DeviceKeyName {
/**
* The curve25519 device key.
*/
  Curve25519 = 0,
/**
* The ed25519 device key.
*/
  Ed25519 = 1,
/**
* An unknown device key.
*/
  Unknown = 2,
}
/**
* A type to encrypt and to decrypt anything that can fit in an
* `Uint8Array`, usually big buffer.
*/
export class Attachment {
  free(): void;
/**
* Encrypt the content of the `Uint8Array`.
*
* It produces an `EncryptedAttachment`, which can be used to
* retrieve the media encryption information, or the encrypted
* data.
* @param {Uint8Array} array
* @returns {EncryptedAttachment}
*/
  static encrypt(array: Uint8Array): EncryptedAttachment;
/**
* Decrypt an `EncryptedAttachment`.
*
* The encrypted attachment can be created manually, or from the
* `encrypt` method.
*
* **Warning**: The encrypted attachment can be used only
* **once**! The encrypted data will still be present, but the
* media encryption info (which contain secrets) will be
* destroyed. It is still possible to get a JSON-encoded backup
* by calling `EncryptedAttachment.mediaEncryptionInfo`.
* @param {EncryptedAttachment} attachment
* @returns {Uint8Array}
*/
  static decrypt(attachment: EncryptedAttachment): Uint8Array;
}
/**
* The private part of the backup key, the one used for recovery.
*/
export class BackupDecryptionKey {
  free(): void;
/**
* Create a new random [`BackupDecryptionKey`].
* @returns {BackupDecryptionKey}
*/
  static createRandomKey(): BackupDecryptionKey;
/**
* Try to create a [`BackupDecryptionKey`] from a base 64 encoded string.
* @param {string} key
* @returns {BackupDecryptionKey}
*/
  static fromBase64(key: string): BackupDecryptionKey;
/**
* Convert the backup decryption key to a base 64 encoded string.
* @returns {string}
*/
  toBase64(): string;
/**
* Try to decrypt a message that was encrypted using the public part of the
* backup key.
* @param {string} ephemeral_key
* @param {string} mac
* @param {string} ciphertext
* @returns {string}
*/
  decryptV1(ephemeral_key: string, mac: string, ciphertext: string): string;
/**
* Get the public part of the backup key.
*/
  readonly megolmV1PublicKey: MegolmV1BackupKey;
}
/**
* Stored versions of the backup keys.
*/
export class BackupKeys {
  free(): void;
/**
* The version that we are using for backups.
*/
  backupVersion?: string;
/**
* The key used to decrypt backed up room keys
*/
  decryptionKey?: BackupDecryptionKey;
/**
* The key used to decrypt backed up room keys, encoded as base64
*
* @deprecated Use `BackupKeys.decryptionKey.toBase64()`
*/
  readonly decryptionKeyBase64: string | undefined;
}
/**
* The base dataset that is important to migrate to the Rust SDK.
*
* Can be imported into the rust store with {@link #migrateBaseData}.
*/
export class BaseMigrationData {
  free(): void;
/**
* Create a new `BaseMigrationData` with default values.
*/
  constructor();
/**
* The backup recovery key, as a base64-encoded string.
*/
  backupRecoveryKey?: string;
/**
* The backup version that is currently active.
*/
  backupVersion?: string;
/**
* The device ID of the account owner.
*/
  deviceId?: DeviceId;
/**
* The pickle string holding the Olm Account, as returned by
* `olm_pickle_account` in libolm.
*/
  pickledAccount: string;
/**
* The private, base64-encoded, master cross-signing key.
*/
  privateCrossSigningMasterKey?: string;
/**
* The private, base64-encoded, self-signing key.
*/
  privateCrossSigningSelfSigningKey?: string;
/**
* The private, base64-encoded, user-signing key.
*/
  privateCrossSigningUserSigningKey?: string;
/**
* The user id of the account owner.
*/
  userId?: UserId;
}
/**
* Information about the cancellation of a verification request or
* verification flow.
*/
export class CancelInfo {
  free(): void;
/**
* Get the human readable reason of the cancellation.
* @returns {string}
*/
  reason(): string;
/**
* Get the `code` (e.g. `m.user`) that was used to cancel the
* verification.
* @returns {string}
*/
  cancelCode(): string;
/**
* Was the verification cancelled by us?
* @returns {boolean}
*/
  cancelledbyUs(): boolean;
}
/**
* A set of requests to be executed when bootstrapping cross-signing using
* {@link OlmMachine.bootstrapCrossSigning}.
*/
export class CrossSigningBootstrapRequests {
  free(): void;
/**
* An optional request to upload a device key.
*
* This will either be `undefined`, or an "outgoing request" as returned by
* {@link OlmMachine.outgoingRequests}.
*
* If it is defined, the request should be sent first, and the result sent
* back with {@link OlmMachine.markRequestAsSent}.
*/
  readonly uploadKeysRequest: any;
/**
* Request to upload key signatures, including those for the cross-signing
* keys, and maybe some for the optional uploaded key too.
*
* Should be sent last.
*/
  readonly uploadSignaturesRequest: SignatureUploadRequest;
/**
* Request to upload the cross-signing keys.
*
* Should be sent second.
*/
  readonly uploadSigningKeysRequest: UploadSigningKeysRequest;
}
/**
* A struct containing private cross signing keys that can be backed
* up or uploaded to the secret store.
*/
export class CrossSigningKeyExport {
  free(): void;
/**
* The seed of the master key encoded as unpadded base64.
*/
  readonly masterKey: string | undefined;
/**
* The seed of the self signing key encoded as unpadded base64.
*/
  readonly self_signing_key: string | undefined;
/**
* The seed of the user signing key encoded as unpadded base64.
*/
  readonly userSigningKey: string | undefined;
}
/**
* Struct representing the state of our private cross signing keys,
* it shows which private cross signing keys we have locally stored.
*/
export class CrossSigningStatus {
  free(): void;
/**
* Do we have the master key?
*/
  readonly hasMaster: boolean;
/**
* Do we have the self signing key? This one is necessary to sign
* our own devices.
*/
  readonly hasSelfSigning: boolean;
/**
* Do we have the user signing key? This one is necessary to sign
* other users.
*/
  readonly hasUserSigning: boolean;
}
/**
* A Curve25519 public key.
*/
export class Curve25519PublicKey {
  free(): void;
/**
* Serialize an Curve25519 public key to an unpadded base64
* representation.
* @returns {string}
*/
  toBase64(): string;
/**
* The number of bytes a Curve25519 public key has.
*/
  readonly length: number;
}
/**
* A decrypted room event.
*/
export class DecryptedRoomEvent {
  free(): void;
/**
* The verification state of the device that sent us the event.
* Note this is the state of the device at the time of
* decryption. It may change in the future if a device gets
* verified or deleted.
* @param {boolean} strict
* @returns {ShieldState | undefined}
*/
  shieldState(strict: boolean): ShieldState | undefined;
/**
* The JSON-encoded decrypted event.
*/
  readonly event: string;
/**
* Returns an empty array
*
* Previously, this returned the chain of Curve25519 keys through which
* this session was forwarded, via `m.forwarded_room_key` events.
* However, that is not cryptographically reliable, and clients should not
* be using it.
*
* @see https://github.com/matrix-org/matrix-spec/issues/1089
*/
  readonly forwardingCurve25519KeyChain: Array<any>;
/**
* The user ID of the event sender, note this is untrusted data
* unless the `verification_state` is as well trusted.
*/
  readonly sender: UserId | undefined;
/**
* The signing Ed25519 key that have created the megolm key that
* was used to decrypt this session.
*/
  readonly senderClaimedEd25519Key: string | undefined;
/**
* The Curve25519 key of the device that created the megolm
* decryption key originally.
*/
  readonly senderCurve25519Key: string | undefined;
/**
* The device ID of the device that sent us the event, note this
* is untrusted data unless `verification_state` is as well
* trusted.
*/
  readonly senderDevice: DeviceId | undefined;
}
/**
* A device represents a E2EE capable client of an user.
*/
export class Device {
  free(): void;
/**
* Request an interactive verification with this device.
*
* Returns a Promise for a 2-element array `[VerificationRequest,
* ToDeviceRequest]`.
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  requestVerification(methods?: Array<any>): Promise<any>;
/**
* Is this device considered to be verified.
*
* This method returns true if either the `is_locally_trusted`
* method returns `true` or if the `is_cross_signing_trusted`
* method returns `true`.
* @returns {boolean}
*/
  isVerified(): boolean;
/**
* Is this device considered to be verified using cross signing.
* @returns {boolean}
*/
  isCrossSigningTrusted(): boolean;
/**
* Is this device cross-signed by its owner?
* @returns {boolean}
*/
  isCrossSignedByOwner(): boolean;
/**
* Set the local trust state of the device to the given state.
*
* This won’t affect any cross signing trust state, this only
* sets a flag marking to have the given trust state.
*
* `trust_state` represents the new trust state that should be
* set for the device.
* @param {number} local_state
* @returns {Promise<any>}
*/
  setLocalTrust(local_state: number): Promise<any>;
/**
* Get the key of the given key algorithm belonging to this device.
* @param {number} algorithm
* @returns {DeviceKey | undefined}
*/
  getKey(algorithm: number): DeviceKey | undefined;
/**
* Is the device locally marked as trusted?
* @returns {boolean}
*/
  isLocallyTrusted(): boolean;
/**
* Is the device locally marked as blacklisted?
*
* Blacklisted devices won’t receive any group sessions.
* @returns {boolean}
*/
  isBlacklisted(): boolean;
/**
* Is the device deleted?
* @returns {boolean}
*/
  isDeleted(): boolean;
/**
* Timestamp representing the first time this device has been seen (in
* milliseconds).
* @returns {bigint}
*/
  firstTimeSeen(): bigint;
/**
* Mark this device as verified.
* Works only if the device is owned by the current user.
*
* Returns a signature upload request that needs to be sent out.
* @returns {Promise<any>}
*/
  verify(): Promise<any>;
/**
* Get the list of algorithms this device supports.
*
* Returns `Array<EncryptionAlgorithm>`.
*/
  readonly algorithms: Array<any>;
/**
* Get the Curve25519 key of the given device.
*/
  readonly curve25519Key: Curve25519PublicKey | undefined;
/**
* The unique ID of the device.
*/
  readonly deviceId: DeviceId;
/**
* Get the human readable name of the device.
*/
  readonly displayName: string | undefined;
/**
* Get the Ed25519 key of the given device.
*/
  readonly ed25519Key: Ed25519PublicKey | undefined;
/**
* Get a map containing all the device keys.
*/
  readonly keys: Map<any, any>;
/**
* Get the trust state of the device.
*/
  readonly localTrustState: number;
/**
* Get a map containing all the device signatures.
*/
  readonly signatures: Signatures;
/**
* The user ID of the device owner.
*/
  readonly userId: UserId;
}
/**
* A Matrix key ID.
*
* Device identifiers in Matrix are completely opaque character
* sequences. This type is provided simply for its semantic value.
*/
export class DeviceId {
  free(): void;
/**
* Create a new `DeviceId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the device ID as a string.
* @returns {string}
*/
  toString(): string;
}
/**
* An enum over the different key types a device can have.
*
* Currently devices have a curve25519 and ed25519 keypair. The keys
* transport format is a base64 encoded string, any unknown key type
* will be left as such a string.
*/
export class DeviceKey {
  free(): void;
/**
* Convert the `DeviceKey` into a base64 encoded string.
* @returns {string}
*/
  toBase64(): string;
/**
* Get the value associated to the `Curve25519` device key name.
*/
  readonly curve25519: Curve25519PublicKey | undefined;
/**
* Get the value associated to the `Ed25519` device key name.
*/
  readonly ed25519: Ed25519PublicKey | undefined;
/**
* Get the name of the device key.
*/
  readonly name: number;
/**
* Get the value associated to the `Unknown` device key name.
*/
  readonly unknown: string | undefined;
}
/**
* The basic key algorithms in the specification.
*/
export class DeviceKeyAlgorithm {
  free(): void;
/**
* Return the device key algorithm as a string.
* @returns {string}
*/
  toString(): string;
/**
* Read the device key algorithm's name. If the name is
* `Unknown`, one may be interested by the `to_string` method to
* read the original name.
*/
  readonly name: number;
}
/**
* A Matrix device key ID.
*
* A key algorithm and a device ID, combined with a ‘:’.
*/
export class DeviceKeyId {
  free(): void;
/**
* Parse/validate and create a new `DeviceKeyId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the device key ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns key algorithm of the device key ID.
*/
  readonly algorithm: DeviceKeyAlgorithm;
/**
* Returns device ID of the device key ID.
*/
  readonly deviceId: DeviceId;
}
/**
* Information on E2E device updates.
*/
export class DeviceLists {
  free(): void;
/**
* Create an empty `DeviceLists`.
*
* `changed` and `left` must be an array of `UserId`.
* @param {Array<any> | undefined} changed
* @param {Array<any> | undefined} left
*/
  constructor(changed?: Array<any>, left?: Array<any>);
/**
* Returns true if there are no device list updates.
* @returns {boolean}
*/
  isEmpty(): boolean;
/**
* List of users who have updated their device identity keys or
* who now share an encrypted room with the client since the
* previous sync
*/
  readonly changed: Array<any>;
/**
* List of users who no longer share encrypted rooms since the
* previous sync response.
*/
  readonly left: Array<any>;
}
/**
* An Ed25519 public key, used to verify digital signatures.
*/
export class Ed25519PublicKey {
  free(): void;
/**
* Serialize an Ed25519 public key to an unpadded base64
* representation.
* @returns {string}
*/
  toBase64(): string;
/**
* The number of bytes an Ed25519 public key has.
*/
  readonly length: number;
}
/**
* An Ed25519 digital signature, can be used to verify the
* authenticity of a message.
*/
export class Ed25519Signature {
  free(): void;
/**
* Try to create an Ed25519 signature from an unpadded base64
* representation.
* @param {string} signature
*/
  constructor(signature: string);
/**
* Serialize a Ed25519 signature to an unpadded base64
* representation.
* @returns {string}
*/
  toBase64(): string;
}
/**
* An emoji that is used for interactive verification using a short
* auth string.
*
* This will contain a single emoji and description from the list of
* emojis from [the specification].
*
* [the specification]: https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji
*/
export class Emoji {
  free(): void;
/**
* The description of the emoji, for example ‘Dog’.
*/
  readonly description: string;
/**
* The emoji symbol that represents a part of the short auth
* string, for example: 🐶
*/
  readonly symbol: string;
}
/**
* An encrypted attachment, usually created from `Attachment.encrypt`.
*/
export class EncryptedAttachment {
  free(): void;
/**
* Create a new encrypted attachment manually.
*
* It needs encrypted data, stored in an `Uint8Array`, and a
* [media encryption
* information](https://docs.rs/matrix-sdk-crypto/latest/matrix_sdk_crypto/struct.MediaEncryptionInfo.html),
* as a JSON-encoded string.
*
* The media encryption information aren't stored as a string:
* they are parsed, validated and fully deserialized.
*
* See [the specification to learn
* more](https://spec.matrix.org/unstable/client-server-api/#extensions-to-mroommessage-msgtypes).
* @param {Uint8Array} encrypted_data
* @param {string} media_encryption_info
*/
  constructor(encrypted_data: Uint8Array, media_encryption_info: string);
/**
* The actual encrypted data.
*
* **Warning**: It returns a **copy** of the entire encrypted
* data; be nice with your memory.
*/
  readonly encryptedData: Uint8Array;
/**
* Check whether the media encryption info has been consumed by
* `Attachment.decrypt` already.
*/
  readonly hasMediaEncryptionInfoBeenConsumed: boolean;
/**
* Return the media encryption info as a JSON-encoded string. The
* structure is fully valid.
*
* If the media encryption info have been consumed already, it
* will return `null`.
*/
  readonly mediaEncryptionInfo: string | undefined;
}
/**
* Struct containing information on how an event was decrypted.
*/
export class EncryptionInfo {
  free(): void;
/**
* The verification state of the device that sent us the event.
* Note this is the state of the device at the time of
* decryption. It may change in the future if a device gets
* verified or deleted.
*
* # Arguments
*
* * `strict` - whether to enable "strict mode" verification. In non-strict
*   mode, unverified users are given no shield, and keys that have been
*   forwarded or restored from an insecure backup are given a grey shield
*   (both get a red shield in strict mode).
* @param {boolean} strict
* @returns {ShieldState}
*/
  shieldState(strict: boolean): ShieldState;
/**
* The user ID of the event sender. Note this is untrusted data
* unless `verification_state` is also trusted.
*/
  readonly sender: UserId;
/**
* The signing Ed25519 key that created the megolm key that
* was used to decrypt this session.
*/
  readonly senderClaimedEd25519Key: string | undefined;
/**
* The Curve25519 key of the device that created the megolm
* decryption key originally.
*/
  readonly senderCurve25519Key: string | undefined;
/**
* The device ID of the device that sent us the event. Note this
* is untrusted data unless `verification_state` is also
* trusted.
*/
  readonly senderDevice: DeviceId | undefined;
}
/**
* Settings for an encrypted room.
*
* This determines the algorithm and rotation periods of a group
* session.
*/
export class EncryptionSettings {
  free(): void;
/**
* Create a new `EncryptionSettings` with default values.
*/
  constructor();
/**
* The encryption algorithm that should be used in the room.
*/
  algorithm: number;
/**
* The history visibility of the room when the session was
* created.
*/
  historyVisibility: number;
/**
* Should untrusted devices receive the room key, or should they be
* excluded from the conversation.
*/
  onlyAllowTrustedDevices: boolean;
/**
* How long the session should be used before changing it,
* expressed in microseconds.
*/
  rotationPeriod: bigint;
/**
* How many messages should be sent before changing the session.
*/
  rotationPeriodMessages: bigint;
}
/**
* A Matrix [event ID].
*
* An `EventId` is generated randomly or converted from a string
* slice, and can be converted back into a string as needed.
*
* [event ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids
*/
export class EventId {
  free(): void;
/**
* Parse/validate and create a new `EventId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the event ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns the event's localpart.
*/
  readonly localpart: string;
/**
* Returns the server name of the event ID.
*/
  readonly serverName: ServerName | undefined;
}
/**
* Struct holding the two public identity keys of an account.
*/
export class IdentityKeys {
  free(): void;
/**
* The Curve25519 public key, used for establish shared secrets.
*/
  curve25519: Curve25519PublicKey;
/**
* The Ed25519 public key, used for signing.
*/
  ed25519: Ed25519PublicKey;
}
/**
* Inbound group session.
*
* Inbound group sessions are used to exchange room messages between a group of
* participants. Inbound group sessions are used to decrypt the room messages.
*/
export class InboundGroupSession {
  free(): void;
/**
* Has the session been imported from a file or server-side backup? As
* opposed to being directly received as an `m.room_key` event.
* @returns {boolean}
*/
  hasBeenImported(): boolean;
/**
* The room where this session is used in.
*/
  readonly roomId: RoomId;
/**
* The Curve25519 key of the sender of this session, as a
* [Curve25519PublicKey].
*/
  readonly senderKey: Curve25519PublicKey;
/**
* Returns the unique identifier for this session.
*/
  readonly sessionId: string;
}
/**
* A request that will back up a batch of room keys to the server
* ([specification]).
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3room_keyskeys
*/
export class KeysBackupRequest {
  free(): void;
/**
* Create a new `KeysBackupRequest`.
* @param {string} id
* @param {string} body
* @param {string} version
*/
  constructor(id: string, body: string, version: string);
/**
* A JSON-encoded string containing the rest of the payload: `rooms`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string;
/**
* Get its request type.
*/
  readonly type: number;
/**
* The backup version that these room keys should be part of.
*/
  readonly version: string;
}
/**
* Data for a request to the `/keys/claim` API endpoint
* ([specification]).
*
* Claims one-time keys that can be used to establish 1-to-1 E2EE
* sessions.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysclaim
*/
export class KeysClaimRequest {
  free(): void;
/**
* Create a new `KeysClaimRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `timeout`,
* `one_time_keys`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Data for a request to the `/keys/query` API endpoint
* ([specification]).
*
* Returns the current devices and identity keys for the given users.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysquery
*/
export class KeysQueryRequest {
  free(): void;
/**
* Create a new `KeysQueryRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `timeout`,
* `device_keys`, `token`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Outgoing Requests * 
* Data for a request to the `/keys/upload` API endpoint
* ([specification]).
*
* Publishes end-to-end encryption keys for the device.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keysupload
*/
export class KeysUploadRequest {
  free(): void;
/**
* Create a new `KeysUploadRequest`.
* @param {string} id
* @param {string} body
*/
  constructor(id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `device_keys`,
* `one_time_keys`, `fallback_keys`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
*/
  readonly id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Represents a signature that is either valid _or_ that could not be
* decoded.
*/
export class MaybeSignature {
  free(): void;
/**
* Check whether the signature has been successfully decoded.
* @returns {boolean}
*/
  isValid(): boolean;
/**
* Check whether the signature could not be successfully decoded.
* @returns {boolean}
*/
  isInvalid(): boolean;
/**
* The base64 encoded string that is claimed to contain a
* signature but could not be decoded, if any.
*/
  readonly invalidSignatureSource: string | undefined;
/**
* The signature, if successfully decoded.
*/
  readonly signature: Signature | undefined;
}
/**
* Js Decryption error with code.
*/
export class MegolmDecryptionError {
  free(): void;
/**
* Description code for the error. See `DecryptionErrorCode`
*/
  readonly code: number;
/**
* detailed description
*/
  readonly description: string;
/**
* Witheld code if any. Only for `UnknownMessageIndex` error code
*/
  readonly maybe_withheld: string | undefined;
}
/**
* The public part of the backup key.
*/
export class MegolmV1BackupKey {
  free(): void;
/**
* Get the full name of the backup algorithm this backup key supports.
*/
  readonly algorithm: string;
/**
* The actual base64 encoded public key.
*/
  readonly publicKeyBase64: string;
}
/**
* Migration routines
*
* The public methods are exposed as static methods on this class, for
* namespacing and to enable easier mocking in unit tests.
*/
export class Migration {
  free(): void;
/**
* Import the base dataset from a libolm-based setup to a vodozemac-based
* setup stored in IndexedDB.
*
* Populates the user credentials, Olm account, backup data, etc. This is
* the first step in the migration process. Once this base data is
* imported, further data can be imported with {@link
* #migrateOlmSessions}, {@link #migrateMegolmSessions}, and TODO room settings.
*
* # Arguments
*
* * `data` - The data to be migrated
* * `pickle_key` - The libolm pickle key that was used to pickle the olm
*   account objects.
* * `store_handle` - A connection to the CryptoStore which will be used to
*   store the vodozemac data.
* @param {BaseMigrationData} data
* @param {Uint8Array} pickle_key
* @param {StoreHandle} store_handle
* @returns {Promise<any>}
*/
  static migrateBaseData(data: BaseMigrationData, pickle_key: Uint8Array, store_handle: StoreHandle): Promise<any>;
/**
* Migrate Olm sessions of a libolm-based setup to a vodozemac-based setup
* stored in an indexedDB crypto store.
*
* Before this method can be used, {@link #migrateBaseData} must be used to
* import the base data into the crypto store.
*
* This method should be called a number of times, with separate batches of
* `sessions`. If a progress display is given, it can be updated after
* each batch is successfully imported.
*
* # Arguments
*
* * `sessions` - An `Array` of {@link PickledSession}s to import.
* * `pickle_key` - The libolm pickle key that was used to pickle the olm
*   session objects.
* * `store_handle` - A connection to the CryptoStore which will be used to
*   store the vodozemac data.
* @param {Array<any>} sessions
* @param {Uint8Array} pickle_key
* @param {StoreHandle} store_handle
* @returns {Promise<any>}
*/
  static migrateOlmSessions(sessions: Array<any>, pickle_key: Uint8Array, store_handle: StoreHandle): Promise<any>;
/**
* Migrate Megolm sessions of a libolm-based setup to a vodozemac-based
* setup stored in an indexedDB crypto store.
*
* Before this method can be used, {@link #migrateBaseData} must be used to
* import the base data into the crypto store.
*
* This method should be called a number of times, with separate batches of
* `sessions`. If a progress display is given, it can be updated after
* each batch is successfully imported.
*
* # Arguments
*
* * `sessions` - An `Array` of {@link PickledInboundGroupSession}s to
*   import.
* * `pickle_key` - The libolm pickle key that was used to pickle the
*   megolm session objects.
* * `store_handle` - A connection to the CryptoStore which will be used to
*   store the vodozemac data.
* @param {Array<any>} sessions
* @param {Uint8Array} pickle_key
* @param {StoreHandle} store_handle
* @returns {Promise<any>}
*/
  static migrateMegolmSessions(sessions: Array<any>, pickle_key: Uint8Array, store_handle: StoreHandle): Promise<any>;
}
/**
* State machine implementation of the Olm/Megolm encryption protocol
* used for Matrix end to end encryption.
*/
export class OlmMachine {
  free(): void;
/**
* Constructor will always fail. To create a new `OlmMachine`, please use
* the `initialize` method.
*
* Why this pattern? `initialize` returns a `Promise`. Returning a
*/
  constructor();
/**
* Create a new `OlmMachine`.
*
* The created machine will keep the encryption keys either in a IndexedDB
* based store, or in a memory store and once the objects is dropped,
* the keys will be lost.
*
* # Arguments
*
* * `user_id` - represents the unique ID of the user that owns this
* machine.
*
* * `device_id` - represents the unique ID of the device
* that owns this machine.
*
* * `store_name` - The name that should be used to open the IndexedDB
*   based database. If this isn't provided, a memory-only store will be
*   used. *Note* the memory-only store will lose your E2EE keys when the
*   `OlmMachine` gets dropped.
*
* * `store_passphrase` - The passphrase that should be used to encrypt the
*   IndexedDB-based store.
* @param {UserId} user_id
* @param {DeviceId} device_id
* @param {string | undefined} store_name
* @param {string | undefined} store_passphrase
* @returns {Promise<any>}
*/
  static initialize(user_id: UserId, device_id: DeviceId, store_name?: string, store_passphrase?: string): Promise<any>;
/**
* Create a new `OlmMachine` backed by an existing store.
*
* # Arguments
*
* * `user_id` - represents the unique ID of the user that owns this
* machine.
*
* * `device_id` - represents the unique ID of the device
* that owns this machine.
*
* * `store_handle` - the connection to the crypto store to be used for
*   this machine.
* @param {UserId} user_id
* @param {DeviceId} device_id
* @param {StoreHandle} store_handle
* @returns {Promise<any>}
*/
  static init_from_store(user_id: UserId, device_id: DeviceId, store_handle: StoreHandle): Promise<any>;
/**
* Get the list of users whose devices we are currently tracking.
*
* A user can be marked for tracking using the
* [`update_tracked_users`](#method.update_tracked_users) method.
*
* Returns a `Set<UserId>`.
* @returns {Promise<any>}
*/
  trackedUsers(): Promise<any>;
/**
* Update the list of tracked users.
*
* The OlmMachine maintains a list of users whose devices we are keeping
* track of: these are known as "tracked users". These must be users
* that we share a room with, so that the server sends us updates for
* their device lists.
*
* # Arguments
*
* * `users` - An array of user ids that should be added to the list of
*   tracked users
*
* Any users that hadn't been seen before will be flagged for a key query
* immediately, and whenever `receive_sync_changes` receives a
* "changed" notification for that user in the future.
*
* Users that were already in the list are unaffected.
* @param {Array<any>} users
* @returns {Promise<any>}
*/
  updateTrackedUsers(users: Array<any>): Promise<any>;
/**
* Handle to-device events and one-time key counts from a sync
* response.
*
* This will decrypt and handle to-device events returning the
* decrypted versions of them.
*
* To decrypt an event from the room timeline call
* `decrypt_room_event`.
*
* # Arguments
*
* * `to_device_events`: the JSON-encoded to-device evens from the `/sync`
*   response
* * `changed_devices`: the mapping of changed and left devices, from the
*   `/sync` response
* * `one_time_keys_counts`: The number of one-time keys on the server,
*   from the `/sync` response. A `Map` from string (encryption algorithm)
*   to number (number of keys).
* * `unused_fallback_keys`: Optionally, a `Set` of unused fallback keys on
*   the server, from the `/sync` response. If this is set, it is used to
*   determine if new fallback keys should be uploaded.
*
* # Returns
*
* A list of JSON strings, containing the decrypted to-device events.
* @param {string} to_device_events
* @param {DeviceLists} changed_devices
* @param {Map<any, any>} one_time_keys_counts
* @param {Set<any> | undefined} unused_fallback_keys
* @returns {Promise<any>}
*/
  receiveSyncChanges(to_device_events: string, changed_devices: DeviceLists, one_time_keys_counts: Map<any, any>, unused_fallback_keys?: Set<any>): Promise<any>;
/**
* Get the outgoing requests that need to be sent out.
*
* This returns a list of values, each of which can be any of:
*   * {@link KeysUploadRequest},
*   * {@link KeysQueryRequest},
*   * {@link KeysClaimRequest},
*   * {@link ToDeviceRequest},
*   * {@link SignatureUploadRequest},
*   * {@link RoomMessageRequest}, or
*   * {@link KeysBackupRequest}.
*
* Those requests need to be sent out to the server and the
* responses need to be passed back to the state machine
* using {@link OlmMachine.markRequestAsSent}.
* @returns {Promise<any>}
*/
  outgoingRequests(): Promise<any>;
/**
* Mark the request with the given request ID as sent (see
* `outgoing_requests`).
*
* Arguments are:
*
* * `request_id` represents the unique ID of the request that was sent
*   out. This is needed to couple the response with the now sent out
*   request.
* * `response_type` represents the type of the request that was sent out.
* * `response` represents the response that was received from the server
*   after the outgoing request was sent out.
* @param {string} request_id
* @param {number} request_type
* @param {string} response
* @returns {Promise<any>}
*/
  markRequestAsSent(request_id: string, request_type: number, response: string): Promise<any>;
/**
* Encrypt a room message for the given room.
*
* **Note**: A room key needs to be shared with the group of users that are
* members in the given room. If this is not done this method will panic.
*
* The usual flow to encrypt an event using this state machine is as
* follows:
*
* 1. Get the one-time key claim request to establish 1:1 Olm sessions for
*    the room members of the room we wish to participate in. This is done
*    using the [`get_missing_sessions()`](Self::get_missing_sessions)
*    method. This method call should be locked per call.
*
* 2. Share a room key with all the room members using the
*    [`share_room_key()`](Self::share_room_key). This method call should
*    be locked per room.
*
* 3. Encrypt the event using this method.
*
* 4. Send the encrypted event to the server.
*
* After the room key is shared steps 1 and 2 will become noops, unless
* there's some changes in the room membership or in the list of devices a
* member has.
*
*
* `room_id` is the ID of the room for which the message should
* be encrypted. `event_type` is the type of the event. `content`
* is the plaintext content of the message that should be
* encrypted.
*
* # Panics
*
* Panics if a group session for the given room wasn't shared
* beforehand.
* @param {RoomId} room_id
* @param {string} event_type
* @param {string} content
* @returns {Promise<any>}
*/
  encryptRoomEvent(room_id: RoomId, event_type: string, content: string): Promise<any>;
/**
* Decrypt an event from a room timeline.
*
* # Arguments
*
* * `event`, the event that should be decrypted.
* * `room_id`, the ID of the room where the event was sent to.
*
* # Returns
*
* A `Promise` which resolves to a {@link DecryptedRoomEvent} instance, or
* rejects with a {@link MegolmDecryptionError} instance.
* @param {string} event
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  decryptRoomEvent(event: string, room_id: RoomId): Promise<any>;
/**
* Get encryption info for a decrypted timeline event.
*
* This recalculates the `EncryptionInfo` data that is returned by
* `decryptRoomEvent`, based on the current
* verification status of the sender, etc.
*
* Returns an error for an unencrypted event.
*
* # Arguments
*
* * `event` - The event to get information for.
* * `room_id` - The ID of the room where the event was sent to.
*
* # Returns
*
* {@link EncryptionInfo}
* @param {string} event
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  getRoomEventEncryptionInfo(event: string, room_id: RoomId): Promise<any>;
/**
* Get the status of the private cross signing keys.
*
* This can be used to check which private cross signing keys we
* have stored locally.
* @returns {Promise<any>}
*/
  crossSigningStatus(): Promise<any>;
/**
* Export all the private cross signing keys we have.
*
* The export will contain the seeds for the ed25519 keys as
* unpadded base64 encoded strings.
*
* Returns `null` if we don’t have any private cross signing keys;
* otherwise returns a `CrossSigningKeyExport`.
* @returns {Promise<any>}
*/
  exportCrossSigningKeys(): Promise<any>;
/**
* Import our private cross signing keys.
*
* The keys should be provided as unpadded-base64-encoded strings.
*
* Returns a `CrossSigningStatus`.
* @param {string | undefined} master_key
* @param {string | undefined} self_signing_key
* @param {string | undefined} user_signing_key
* @returns {Promise<any>}
*/
  importCrossSigningKeys(master_key?: string, self_signing_key?: string, user_signing_key?: string): Promise<any>;
/**
* Create a new cross signing identity and get the upload request
* to push the new public keys to the server.
*
* Warning: This will delete any existing cross signing keys that
* might exist on the server and thus will reset the trust
* between all the devices.
*
* Uploading these keys will require user interactive auth.
*
* # Arguments
*
* * `reset`, whether the method should create a new identity or use the
*   existing one during the request. If set to true, the request will
*   attempt to upload a new identity. If set to false, the request will
*   attempt to upload the existing identity. Since the uploading process
*   requires user interactive authentication, which involves sending out
*   the same request multiple times, setting this argument to false
*   enables you to reuse the same request.
*
* Returns a {@link CrossSigningBootstrapRequests}.
* @param {boolean} reset
* @returns {Promise<any>}
*/
  bootstrapCrossSigning(reset: boolean): Promise<any>;
/**
* Get the cross signing user identity of a user.
*
* Returns a promise for an `OwnUserIdentity`, a `UserIdentity`, or
* `undefined`.
* @param {UserId} user_id
* @returns {Promise<any>}
*/
  getIdentity(user_id: UserId): Promise<any>;
/**
* Sign the given message using our device key and if available
* cross-signing master key.
* @param {string} message
* @returns {Promise<any>}
*/
  sign(message: string): Promise<any>;
/**
* Invalidate the currently active outbound group session for the
* given room.
*
* Returns true if a session was invalidated, false if there was
* no session to invalidate.
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  invalidateGroupSession(room_id: RoomId): Promise<any>;
/**
* Get to-device requests to share a room key with users in a room.
*
* `room_id` is the room ID. `users` is an array of `UserId`
* objects. `encryption_settings` are an `EncryptionSettings`
* object.
*
* Note: Care should be taken that only one such request at a
* time is in flight for the same room, e.g. using a lock.
*
* Returns an array of `ToDeviceRequest`s.
* @param {RoomId} room_id
* @param {Array<any>} users
* @param {EncryptionSettings} encryption_settings
* @returns {Promise<any>}
*/
  shareRoomKey(room_id: RoomId, users: Array<any>, encryption_settings: EncryptionSettings): Promise<any>;
/**
* Generate an "out-of-band" key query request for the given set of users.
*
* This can be useful if we need the results from `getIdentity` or
* `getUserDevices` to be as up-to-date as possible.
*
* Returns a `KeysQueryRequest` object. The response of the request should
* be passed to the `OlmMachine` with the `mark_request_as_sent`.
* @param {Array<any>} users
* @returns {KeysQueryRequest}
*/
  queryKeysForUsers(users: Array<any>): KeysQueryRequest;
/**
* Get the a key claiming request for the user/device pairs that
* we are missing Olm sessions for.
*
* Returns `null` if no key claiming request needs to be sent
* out, otherwise it returns a `KeysClaimRequest` object.
*
* Sessions need to be established between devices so group
* sessions for a room can be shared with them.
*
* This should be called every time a group session needs to be
* shared as well as between sync calls. After a sync some
* devices may request room keys without us having a valid Olm
* session with them, making it impossible to server the room key
* request, thus it’s necessary to check for missing sessions
* between sync as well.
*
* Note: Care should be taken that only one such request at a
* time is in flight, e.g. using a lock.
*
* The response of a successful key claiming requests needs to be
* passed to the `OlmMachine` with the `mark_request_as_sent`.
*
* `users` represents the list of users that we should check if
* we lack a session with one of their devices. This can be an
* empty iterator when calling this method between sync requests.
* @param {Array<any>} users
* @returns {Promise<any>}
*/
  getMissingSessions(users: Array<any>): Promise<any>;
/**
* Get a map holding all the devices of a user.
*
* ### Parameters
*
* * `user_id` - The unique ID of the user that the device belongs to.
*
* * `timeout_secs` - The amount of time we should wait for a `/keys/query`
*   response before returning if the user's device list has been marked as
*   stale. **Note**, this assumes that the requests from {@link
*   OlmMachine.outgoingRequests} are being processed and sent out.
*
*   If unset, we will return immediately even if the device list is stale.
*
* ### Returns
*
* A {@link UserDevices} object.
* @param {UserId} user_id
* @param {number | undefined} timeout_secs
* @returns {Promise<any>}
*/
  getUserDevices(user_id: UserId, timeout_secs?: number): Promise<any>;
/**
* Get a specific device of a user.
*
* ### Parameters
*
* * `user_id` - The unique ID of the user that the device belongs to.
*
* * `device_id` - The unique ID of the device.
*
* * `timeout_secs` - The amount of time we should wait for a `/keys/query`
*   response before returning if the user's device list has been marked as
*   stale. **Note**, this assumes that the requests from {@link
*   OlmMachine.outgoingRequests} are being processed and sent out.
*
*   If unset, we will return immediately even if the device list is stale.
*
* ### Returns
*
* If the device is known, a {@link Device}. Otherwise, `undefined`.
* @param {UserId} user_id
* @param {DeviceId} device_id
* @param {number | undefined} timeout_secs
* @returns {Promise<any>}
*/
  getDevice(user_id: UserId, device_id: DeviceId, timeout_secs?: number): Promise<any>;
/**
* Get a verification object for the given user ID with the given
* flow ID (a to-device request ID if the verification has been
* requested by a to-device request, or a room event ID if the
* verification has been requested by a room event).
*
* It returns a “`Verification` object”, which is either a `Sas`
* or `Qr` object.
* @param {UserId} user_id
* @param {string} flow_id
* @returns {any}
*/
  getVerification(user_id: UserId, flow_id: string): any;
/**
* Get a verification request object with the given flow ID.
* @param {UserId} user_id
* @param {string} flow_id
* @returns {VerificationRequest | undefined}
*/
  getVerificationRequest(user_id: UserId, flow_id: string): VerificationRequest | undefined;
/**
* Get all the verification requests of a given user.
* @param {UserId} user_id
* @returns {Array<any>}
*/
  getVerificationRequests(user_id: UserId): Array<any>;
/**
* Receive a verification event.
*
* This method can be used to pass verification events that are happening
* in rooms to the `OlmMachine`. The event should be in the decrypted form.
* @param {string} event
* @param {RoomId} room_id
* @returns {Promise<any>}
*/
  receiveVerificationEvent(event: string, room_id: RoomId): Promise<any>;
/**
* Export the keys that match the given predicate.
*
* `predicate` is a closure that will be called for every known
* `InboundGroupSession`, which represents a room key. If the closure
* returns `true`, the `InboundGroupSession` will be included in the
* export, otherwise it won't.
* @param {Function} predicate
* @returns {Promise<any>}
*/
  exportRoomKeys(predicate: Function): Promise<any>;
/**
* Import the given room keys into our store.
*
* Mostly, a deprecated alias for `importExportedRoomKeys`, though the
* return type is different.
*
* Returns a String containing a JSON-encoded object, holding three
* properties:
*  * `total_count` (the total number of keys found in the export data).
*  * `imported_count` (the number of keys that were imported).
*  * `keys` (the keys that were imported; a map from room id to a map of
*    the sender key to a list of session ids).
*
* @deprecated Use `importExportedRoomKeys` or `importBackedUpRoomKeys`.
* @param {string} exported_room_keys
* @param {Function} progress_listener
* @returns {Promise<any>}
*/
  importRoomKeys(exported_room_keys: string, progress_listener: Function): Promise<any>;
/**
* Import the given room keys into our store.
*
* `exported_keys` is a JSON-encoded list of previously exported keys that
* should be imported into our store. If we already have a better
* version of a key, the key will _not_ be imported.
*
* `progress_listener` is a closure that takes 2 `BigInt` arguments:
* `progress` and `total`, and returns nothing.
*
* Returns a {@link RoomKeyImportResult}.
* @param {string} exported_room_keys
* @param {Function} progress_listener
* @returns {Promise<any>}
*/
  importExportedRoomKeys(exported_room_keys: string, progress_listener: Function): Promise<any>;
/**
* Import the given room keys into our store.
*
* # Arguments
*
* * `backed_up_room_keys`: keys that were retrieved from backup and that
*   should be added to our store (provided they are better than our
*   current versions of those keys). Specifically, it should be a Map from
*   {@link RoomId}, to a Map from session ID to a (decrypted) session data
*   structure.
*
* * `progress_listener`: an optional callback that takes 2 arguments:
*   `progress` and `total`, and returns nothing.
*
* # Returns
*
* A {@link RoomKeyImportResult}.
* @param {Map<any, any>} backed_up_room_keys
* @param {Function | undefined} progress_listener
* @returns {Promise<any>}
*/
  importBackedUpRoomKeys(backed_up_room_keys: Map<any, any>, progress_listener?: Function): Promise<any>;
/**
* Store the backup decryption key in the crypto store.
*
* This is useful if the client wants to support gossiping of the backup
* key.
*
* Returns `Promise<void>`.
* @param {BackupDecryptionKey} decryption_key
* @param {string} version
* @returns {Promise<any>}
*/
  saveBackupDecryptionKey(decryption_key: BackupDecryptionKey, version: string): Promise<any>;
/**
* Get the backup keys we have saved in our store.
* Returns a `Promise` for {@link BackupKeys}.
* @returns {Promise<any>}
*/
  getBackupKeys(): Promise<any>;
/**
* Check if the given backup has been verified by us or by another of our
* devices that we trust.
*
* The `backup_info` should be a Javascript object with the following
* format:
*
* ```json
* {
*     "algorithm": "m.megolm_backup.v1.curve25519-aes-sha2",
*     "auth_data": {
*         "public_key":"XjhWTCjW7l59pbfx9tlCBQolfnIQWARoKOzjTOPSlWM",
*         "signatures": {}
*     }
* }
* ```
*
* Returns a {@link SignatureVerification} object.
* @param {any} backup_info
* @returns {Promise<any>}
*/
  verifyBackup(backup_info: any): Promise<any>;
/**
* Activate the given backup key to be used with the given backup version.
*
* **Warning**: The caller needs to make sure that the given `BackupKey` is
* trusted, otherwise we might be encrypting room keys that a malicious
* party could decrypt.
*
* The {@link #verifyBackup} method can be used to do so.
*
* Returns `Promise<void>`.
* @param {string} public_key_base_64
* @param {string} version
* @returns {Promise<any>}
*/
  enableBackupV1(public_key_base_64: string, version: string): Promise<any>;
/**
* Are we able to encrypt room keys.
*
* This returns true if we have an active `BackupKey` and backup version
* registered with the state machine.
*
* Returns `Promise<bool>`.
* @returns {Promise<any>}
*/
  isBackupEnabled(): Promise<any>;
/**
* Disable and reset our backup state.
*
* This will remove any pending backup request, remove the backup key and
* reset the backup state of each room key we have.
*
* Returns `Promise<void>`.
* @returns {Promise<any>}
*/
  disableBackup(): Promise<any>;
/**
* Encrypt a batch of room keys and return a request that needs to be sent
* out to backup the room keys.
*
* Returns an optional {@link KeysBackupRequest}.
* @returns {Promise<any>}
*/
  backupRoomKeys(): Promise<any>;
/**
* Get the number of backed up room keys and the total number of room keys.
* Returns a {@link RoomKeyCounts}.
* @returns {Promise<any>}
*/
  roomKeyCounts(): Promise<any>;
/**
* Encrypt the list of exported room keys using the given passphrase.
*
* `exported_room_keys` is a list of sessions that should be encrypted
* (it's generally returned by `export_room_keys`). `passphrase` is the
* passphrase that will be used to encrypt the exported room keys. And
* `rounds` is the number of rounds that should be used for the key
* derivation when the passphrase gets turned into an AES key. More rounds
* are increasingly computationnally intensive and as such help against
* brute-force attacks. Should be at least `10_000`, while values in the
* `100_000` ranges should be preferred.
* @param {string} exported_room_keys
* @param {string} passphrase
* @param {number} rounds
* @returns {string}
*/
  static encryptExportedRoomKeys(exported_room_keys: string, passphrase: string, rounds: number): string;
/**
* Try to decrypt a reader into a list of exported room keys.
*
* `encrypted_exported_room_keys` is the result from
* `encrypt_exported_room_keys`. `passphrase` is the passphrase that was
* used when calling `encrypt_exported_room_keys`.
* @param {string} encrypted_exported_room_keys
* @param {string} passphrase
* @returns {string}
*/
  static decryptExportedRoomKeys(encrypted_exported_room_keys: string, passphrase: string): string;
/**
* Register a callback which will be called whenever there is an update to
* a room key.
*
* `callback` should be a function that takes a single argument (an array
* of {@link RoomKeyInfo}) and returns a Promise.
* @param {Function} callback
* @returns {Promise<void>}
*/
  registerRoomKeyUpdatedCallback(callback: Function): Promise<void>;
/**
* Register a callback which will be called whenever there is an update to
* a user identity.
*
* `callback` should be a function that takes a single argument (a {@link
* UserId}) and returns a Promise.
* @param {Function} callback
* @returns {Promise<void>}
*/
  registerUserIdentityUpdatedCallback(callback: Function): Promise<void>;
/**
* Register a callback which will be called whenever a secret
* (`m.secret.send`) is received.
*
* The only secret this will currently broadcast is the
* `m.megolm_backup.v1` (the cross signing secrets are handled internally).
*
* To request a secret from other devices, a client sends an
* `m.secret.request` device event with `action` set to `request` and
* `name` set to the identifier of the secret. A device that wishes to
* share the secret will reply with an `m.secret.send` event, encrypted
* using olm.
*
* The secrets are guaranteed to have been received over a 1-to-1 encrypted
* to_device message from a one of the user's own verified devices.
*
* See https://matrix-org.github.io/matrix-rust-sdk/matrix_sdk_crypto/store/struct.Store.html#method.secrets_stream for more information.
*
* `callback` should be a function that takes 2 arguments: the secret name
* (string) and value (string).
*
* **Note**: if the secret is valid and handled on the javascript side, the
* secret inbox should be cleared by calling
* `delete_secrets_from_inbox`.
* @param {Function} callback
* @returns {Promise<void>}
*/
  registerReceiveSecretCallback(callback: Function): Promise<void>;
/**
* Get all the secrets with the given secret_name we have currently
* stored.
* The only secret this will currently return is the
* `m.megolm_backup.v1` secret.
*
* Usually you would just register a callback with
* [`register_receive_secret_callback`], but if the client is shut down
* before handling them, this method can be used to retrieve them.
* This method should therefore be called at client startup to retrieve any
* secrets received during the previous session.
*
* The secrets are guaranteed to have been received over a 1-to-1 encrypted
* to_device message from one of the user's own verified devices.
*
* Returns a `Promise` for a `Set` of `String` corresponding to the secret
* values.
*
* If the secret is valid and handled, the secret inbox should be cleared
* by calling `delete_secrets_from_inbox`.
* @param {string} secret_name
* @returns {Promise<Promise<any>>}
*/
  getSecretsFromInbox(secret_name: string): Promise<Promise<any>>;
/**
* Delete all secrets with the given secret name from the inbox.
*
* Should be called after handling the secrets with
* `get_secrets_from_inbox`.
*
* # Arguments
*
* * `secret_name` - The name of the secret to delete.
* @param {string} secret_name
* @returns {Promise<Promise<any>>}
*/
  deleteSecretsFromInbox(secret_name: string): Promise<Promise<any>>;
/**
* Request missing local secrets from our other trusted devices.
*
* "Local secrets" refers to secrets which can be shared between trusted
* devices, such as private cross-signing keys, and the megolm backup
* decryption key.
*
* This method will cause the sdk to generated outgoing secret requests
* (`m.secret.request`) to get the missing secrets. These requests will
* then be returned by a future call to {@link
* OlmMachine#outgoing_requests}.
*
* # Returns
*
* A `Promise` for a `bool` result, which will be true if  secrets were
* missing, and a request was generated.
* @returns {Promise<Promise<any>>}
*/
  requestMissingSecretsIfNeeded(): Promise<Promise<any>>;
/**
* Shut down the `OlmMachine`.
*
* The `OlmMachine` cannot be used after this method has been called.
*
* All associated resources will be closed too, like IndexedDB
* connections.
*/
  close(): void;
/**
* The unique device ID that identifies this `OlmMachine`.
*/
  readonly deviceId: DeviceId;
/**
* Get the display name of our own device.
*/
  readonly displayName: Promise<any>;
/**
* Get the public parts of our Olm identity keys.
*/
  readonly identityKeys: IdentityKeys;
/**
* Whether room key forwarding is enabled.
*
* If room key forwarding is enabled, we will automatically reply to
* incoming `m.room_key_request` messages from verified devices by
* forwarding the requested key (if we have it).
*/
  roomKeyForwardingEnabled: boolean;
/**
* Whether automatic transmission of room key requests is enabled.
*
* Room key requests allow the device to request room keys that it might
* have missed in the original share using `m.room_key_request`
* events.
*/
  roomKeyRequestsEnabled: boolean;
/**
* The unique user ID that owns this `OlmMachine` instance.
*/
  readonly userId: UserId;
}
/**
* Struct representing a cross signing identity of a user.
*
* This is the user identity of a user that is our own.
*/
export class OwnUserIdentity {
  free(): void;
/**
* Is this user identity verified?
* @returns {boolean}
*/
  isVerified(): boolean;
/**
* Mark our user identity as verified.
*
* This will mark the identity locally as verified and sign it with our own
* device.
*
* Returns a signature upload request that needs to be sent out.
* @returns {Promise<any>}
*/
  verify(): Promise<any>;
/**
* Send a verification request to our other devices.
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  requestVerification(methods?: Array<any>): Promise<any>;
/**
* Does our user identity trust our own device, i.e. have we signed our own
* device keys with our self-signing key?
* @returns {Promise<any>}
*/
  trustsOurOwnDevice(): Promise<any>;
/**
* Get the master key of the identity.
*/
  readonly masterKey: string;
/**
* Get the self-signing key of the identity.
*/
  readonly selfSigningKey: string;
/**
* Get the user-signing key of the identity, this is only present for our
* own user identity..
*/
  readonly userSigningKey: string;
}
/**
* A pickled version of an `InboundGroupSession`.
*
* Holds all the information that needs to be stored in a database to restore
* an InboundGroupSession.
*/
export class PickledInboundGroupSession {
  free(): void;
/**
* Construct a new `PickledInboundGroupSession`, with default values.
*/
  constructor();
/**
* Flag remembering if the session has been backed up.
*/
  backedUp: boolean;
/**
* Flag remembering if the session was directly sent to us by the sender
* or if it was imported.
*/
  imported: boolean;
/**
* The pickle string holding the Megolm Session, as returned by
* `olm_pickle_inbound_group_session` in libolm.
*/
  pickle: string;
/**
* The id of the room that the session is used in.
*
* Nullable so that a `PickledInboundGroupSession` can be constructed
* incrementally. Must be populated!
*/
  roomId?: RoomId;
/**
* The public curve25519 key of the account that sent us the session.
*/
  senderKey: string;
/**
* The public ed25519 key of the account that sent us the session.
*/
  senderSigningKey: string;
}
/**
* A pickled version of a `Session`.
*
* Holds all the information that needs to be stored in a database to restore
* an Olm Session. Can be imported into the rust store with {@link
* #migrateOlmSessions}.
*/
export class PickledSession {
  free(): void;
/**
* Construct a new `PickledSession`, with default values.
*/
  constructor();
/**
* Was the session created using a fallback key?
*/
  createdUsingFallbackKey: boolean;
/**
* When the session was created.
*/
  creationTime: Date;
/**
* When the session was last used.
*/
  lastUseTime: Date;
/**
* The pickle string holding the Olm Session, as returned by
* `olm_pickle_session` in libolm.
*/
  pickle: string;
/**
* The base64-encoded public curve25519 key of the other user that we share
* this session with.
*/
  senderKey: string;
}
/**
* QR code based verification.
*/
export class Qr {
  free(): void;
/**
* Get the current state of this request.
*
* Returns a `QrState`.
* @returns {number}
*/
  state(): number;
/**
* Has the QR verification been scanned by the other side.
*
* When the verification object is in this state it’s required
* that the user confirms that the other side has scanned the QR
* code.
* @returns {boolean}
*/
  hasBeenScanned(): boolean;
/**
* Has the scanning of the QR code been confirmed by us?
* @returns {boolean}
*/
  hasBeenConfirmed(): boolean;
/**
* Did we initiate the verification request?
* @returns {boolean}
*/
  weStarted(): boolean;
/**
* Get info about the cancellation if the verification flow has
* been cancelled.
* @returns {CancelInfo | undefined}
*/
  cancelInfo(): CancelInfo | undefined;
/**
* Has the verification flow completed?
* @returns {boolean}
*/
  isDone(): boolean;
/**
* Has the verification flow been cancelled?
* @returns {boolean}
*/
  isCancelled(): boolean;
/**
* Is this a verification that is verifying one of our own devices?
* @returns {boolean}
*/
  isSelfVerification(): boolean;
/**
* Have we successfully scanned the QR code and are able to send
* a reciprocation event?
* @returns {boolean}
*/
  reciprocated(): boolean;
/**
* Generate a QR code object that is representing this
* verification flow.
*
* The QrCode can then be rendered as an image or as an unicode
* string.
*
* The `to_bytes` method can be used to instead output the raw
* bytes that should be encoded as a QR code.
*
* Returns a `QrCode`.
* @returns {QrCode}
*/
  toQrCode(): QrCode;
/**
* Generate a the raw bytes that should be encoded as a QR code
* is representing this verification flow.
*
* The `to_qr_code` method can be used to instead output a QrCode
* object that can be rendered.
* @returns {Uint8ClampedArray}
*/
  toBytes(): Uint8ClampedArray;
/**
* Notify the other side that we have successfully scanned the QR
* code and that the QR verification flow can start.
*
* This will return some OutgoingContent if the object is in the
* correct state to start the verification flow, otherwise None.
* @returns {any}
*/
  reciprocate(): any;
/**
* Confirm that the other side has scanned our QR code.
*
* Returns either an `OutgoingRequest` which should be sent out, or
* `undefined` if the verification is already confirmed.
* @returns {any}
*/
  confirmScanning(): any;
/**
* Cancel the verification flow.
*
* Returns either an `OutgoingRequest` which should be sent out, or
* `undefined` if the verification is already cancelled.
* @returns {any}
*/
  cancel(): any;
/**
* Cancel the verification.
*
* This cancels the verification with given code (e.g. `m.user`).
*
* Returns either an `OutgoingRequest` which should be sent out, or
* `undefined` if the verification is already cancelled.
* @param {string} code
* @returns {any}
*/
  cancelWithCode(code: string): any;
/**
* Register a callback which will be called whenever there is an update to
* the request
*
* The `callback` is called with no parameters.
* @param {Function} callback
*/
  registerChangesCallback(callback: Function): void;
/**
* Get the unique ID that identifies this QR verification flow,
* be either a to-device request ID or a room event ID.
*/
  readonly flowId: string;
/**
* Get the device ID of the other side.
*/
  readonly otherDeviceId: DeviceId;
/**
* Get the user id of the other user that is participating in
* this verification flow.
*/
  readonly otherUserId: UserId;
/**
* Get the room id if the verification is happening inside a
* room.
*/
  readonly roomId: RoomId | undefined;
/**
* Get our own user ID.
*/
  readonly userId: UserId;
}
/**
* A QR code.
*/
export class QrCode {
  free(): void;
/**
* Render the QR code into a `Uint8ClampedArray` where 1 represents a
* dark pixel and 0 a white pixel.
* @returns {Uint8ClampedArray}
*/
  renderIntoBuffer(): Uint8ClampedArray;
}
/**
* A scanned QR code.
*/
export class QrCodeScan {
  free(): void;
/**
* Parse the decoded payload of a QR code in byte slice form.
*
* This method is useful if you would like to do your own custom QR code
* decoding.
* @param {Uint8ClampedArray} buffer
* @returns {QrCodeScan}
*/
  static fromBytes(buffer: Uint8ClampedArray): QrCodeScan;
}
/**
* A Matrix [room ID].
*
* [room ID]: https://spec.matrix.org/v1.2/appendices/#room-ids-and-event-ids
*/
export class RoomId {
  free(): void;
/**
* Parse/validate and create a new `RoomId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Return the room ID as a string.
* @returns {string}
*/
  toString(): string;
}
/**
* Struct holding the number of room keys we have.
*/
export class RoomKeyCounts {
  free(): void;
/**
* The number of backed up room keys.
*/
  backedUp: number;
/**
* The total number of room keys.
*/
  total: number;
}
/**
* The result of a call to {@link OlmMachine.importExportedRoomKeys} or
* {@link OlmMachine.importBackedUpRoomKeys}.
*/
export class RoomKeyImportResult {
  free(): void;
/**
* The keys that were imported.
*
* A Map from room id to a Map of the sender key to a Set of session ids.
*
* Typescript type: `Map<string, Map<string, Set<string>>`.
* @returns {Map<any, any>}
*/
  keys(): Map<any, any>;
/**
* The number of room keys that were imported.
*/
  readonly importedCount: number;
/**
* The total number of room keys that were found in the export.
*/
  readonly totalCount: number;
}
/**
* Information on a room key that has been received or imported.
*/
export class RoomKeyInfo {
  free(): void;
/**
* The {@link EncryptionAlgorithm} that this key is used for. Will be one
* of the `m.megolm.*` algorithms.
*/
  readonly algorithm: number;
/**
* The room where the key is used.
*/
  readonly roomId: RoomId;
/**
* The Curve25519 key of the device which initiated the session originally.
*/
  readonly senderKey: Curve25519PublicKey;
/**
* The ID of the session that the key is for.
*/
  readonly sessionId: string;
}
/**
* A customized owned request type for sending out room messages
* ([specification]).
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3roomsroomidsendeventtypetxnid
*/
export class RoomMessageRequest {
  free(): void;
/**
* Create a new `RoomMessageRequest`.
* @param {string} id
* @param {string} room_id
* @param {string} txn_id
* @param {string} event_type
* @param {string} content
*/
  constructor(id: string, room_id: string, txn_id: string, event_type: string, content: string);
/**
* A JSON-encoded string containing the message's content.
*/
  readonly body: string;
/**
* A string representing the type of event to be sent.
*/
  readonly event_type: string;
/**
* The request ID.
*/
  readonly id: string;
/**
* A string representing the room to send the event to.
*/
  readonly room_id: string;
/**
* A string representing the transaction ID for this event.
*
* Clients should generate an ID unique across requests with the same
* access token; it will be used by the server to ensure idempotency of
* requests.
*/
  readonly txn_id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Short Authentication String (SAS) verification.
*/
export class Sas {
  free(): void;
/**
* Does this verification flow support displaying emoji for the
* short authentication string?
* @returns {boolean}
*/
  supportsEmoji(): boolean;
/**
* Did this verification flow start from a verification request?
* @returns {boolean}
*/
  startedFromRequest(): boolean;
/**
* Is this a verification that is verifying one of our own
* devices?
* @returns {boolean}
*/
  isSelfVerification(): boolean;
/**
* Have we confirmed that the short auth string matches?
* @returns {boolean}
*/
  haveWeConfirmed(): boolean;
/**
* Has the verification been accepted by both parties?
* @returns {boolean}
*/
  hasBeenAccepted(): boolean;
/**
* Get info about the cancellation if the verification flow has
* been cancelled.
* @returns {CancelInfo | undefined}
*/
  cancelInfo(): CancelInfo | undefined;
/**
* True if we initiated the verification flow (ie, we sent the
* `m.key.verification.request`).
* @returns {boolean}
*/
  weStarted(): boolean;
/**
* Accept the SAS verification.
*
* This does nothing (and returns `undefined`) if the verification was
* already accepted, otherwise it returns an `OutgoingRequest`
* that needs to be sent out.
* @returns {any}
*/
  accept(): any;
/**
* Confirm the SAS verification.
*
* This confirms that the short auth strings match on both sides.
*
* Does nothing if we’re not in a state where we can confirm the
* short auth string.
*
* Returns a `Promise` for an array of `OutgoingRequest`s.
* @returns {Promise<any>}
*/
  confirm(): Promise<any>;
/**
* Cancel the verification.
*
* Returns either an `OutgoingRequest` which should be sent out, or
* `undefined` if the verification is already cancelled.
* @returns {any}
*/
  cancel(): any;
/**
* Cancel the verification.
*
* This cancels the verification with given code (e.g. `m.user`).
*
* Returns either an `OutgoingRequest` which should be sent out, or
* `undefined` if the verification is already cancelled.
* @param {string} code
* @returns {any}
*/
  cancelWithCode(code: string): any;
/**
* Has the SAS verification flow timed out?
* @returns {boolean}
*/
  timedOut(): boolean;
/**
* Are we in a state where we can show the short auth string?
* @returns {boolean}
*/
  canBePresented(): boolean;
/**
* Is the SAS flow done?
* @returns {boolean}
*/
  isDone(): boolean;
/**
* Is the SAS flow cancelled?
* @returns {boolean}
*/
  isCancelled(): boolean;
/**
* Get the emoji version of the short auth string.
*
* Returns `undefined` if we can't yet present the short auth string,
* otherwise an array of seven `Emoji` objects.
* @returns {Array<any> | undefined}
*/
  emoji(): Array<any> | undefined;
/**
* Get the index of the emoji representing the short auth string
*
* Returns `undefined` if we can’t yet present the short auth
* string, otherwise seven `u8` numbers in the range from 0 to 63
* inclusive which can be converted to an emoji using [the
* relevant specification
* entry](https://spec.matrix.org/unstable/client-server-api/#sas-method-emoji).
* @returns {Array<any> | undefined}
*/
  emojiIndex(): Array<any> | undefined;
/**
* Get the decimal version of the short auth string.
*
* Returns None if we can’t yet present the short auth string,
* otherwise a tuple containing three 4-digit integers that
* represent the short auth string.
* @returns {Array<any> | undefined}
*/
  decimals(): Array<any> | undefined;
/**
* Register a callback which will be called whenever there is an update to
* the request.
*
* The `callback` is called with no parameters.
* @param {Function} callback
*/
  registerChangesCallback(callback: Function): void;
/**
* Get our own device ID.
*/
  readonly deviceId: DeviceId;
/**
* Get the unique ID that identifies this SAS verification flow,
* be either a to-device request ID or a room event ID.
*/
  readonly flowId: string;
/**
* Get the device ID of the other side.
*/
  readonly otherDeviceId: DeviceId;
/**
* Get the user id of the other side.
*/
  readonly otherUserId: UserId;
/**
* Get the room ID if the verification is happening inside a
* room.
*/
  readonly roomId: RoomId | undefined;
/**
* Get our own user ID.
*/
  readonly userId: UserId;
}
/**
* A Matrix-spec compliant [server name].
*
* It consists of a host and an optional port (separated by a colon if
* present).
*
* [server name]: https://spec.matrix.org/v1.2/appendices/#server-name
*/
export class ServerName {
  free(): void;
/**
* Parse/validate and create a new `ServerName`.
* @param {string} name
*/
  constructor(name: string);
/**
* Returns true if and only if the server name is an IPv4 or IPv6
* address.
* @returns {boolean}
*/
  isIpLiteral(): boolean;
/**
* Returns the host of the server name.
*
* That is: Return the part of the server before `:<port>` or the
* full server name if there is no port.
*/
  readonly host: string;
/**
* Returns the port of the server name if any.
*/
  readonly port: number | undefined;
}
/**
* Take a look at [`matrix_sdk_common::deserialized_responses::ShieldState`]
* for more info.
*/
export class ShieldState {
  free(): void;
/**
* The shield color
*/
  color: number;
/**
* Error message that can be displayed as a tooltip
*/
  readonly message: string | undefined;
}
/**
* Represents a potentially decoded signature (but not a validated
* one).
*/
export class Signature {
  free(): void;
/**
* Convert the signature to a base64 encoded string.
* @returns {string}
*/
  toBase64(): string;
/**
* Get the Ed25519 signature, if this is one.
*/
  readonly ed25519: Ed25519Signature | undefined;
}
/**
* Data for a request to the `/keys/signatures/upload` API endpoint
* ([specification]).
*
* Publishes cross-signing signatures for the user.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#post_matrixclientv3keyssignaturesupload
*/
export class SignatureUploadRequest {
  free(): void;
/**
* Create a new `SignatureUploadRequest`.
* @param {string} id
* @param {string} signed_keys
*/
  constructor(id: string, signed_keys: string);
/**
* A JSON-encoded string containing the payload of the request
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* The request ID.
* Some signature upload will have to an `id` field, some won't.
* They have one when they are created automatically during an interactive
* verification, otherwise they don't.
*/
  readonly id: string | undefined;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* The result of a signature verification of a signed JSON object.
*/
export class SignatureVerification {
  free(): void;
/**
* Is the result considered to be trusted?
*
* This tells us if the result has a valid signature from any of the
* following:
*
* * Our own device
* * Our own user identity, provided the identity is trusted as well
* * Any of our own devices, provided the device is trusted as well
* @returns {boolean}
*/
  trusted(): boolean;
/**
* Give the backup signature state from the current device.
* See SignatureState for values
*/
  readonly deviceState: number;
/**
* Give the backup signature state from the current user identity.
* See SignatureState for values
*/
  readonly userState: number;
}
/**
* A collection of `Signature`.
*/
export class Signatures {
  free(): void;
/**
* Creates a new, empty, signatures collection.
*/
  constructor();
/**
* Add the given signature from the given signer and the given key ID to
* the collection.
* @param {UserId} signer
* @param {DeviceKeyId} key_id
* @param {Ed25519Signature} signature
* @returns {MaybeSignature | undefined}
*/
  addSignature(signer: UserId, key_id: DeviceKeyId, signature: Ed25519Signature): MaybeSignature | undefined;
/**
* Try to find an Ed25519 signature from the given signer with
* the given key ID.
* @param {UserId} signer
* @param {DeviceKeyId} key_id
* @returns {Ed25519Signature | undefined}
*/
  getSignature(signer: UserId, key_id: DeviceKeyId): Ed25519Signature | undefined;
/**
* Get the map of signatures that belong to the given user.
* @param {UserId} signer
* @returns {Map<any, any> | undefined}
*/
  get(signer: UserId): Map<any, any> | undefined;
/**
* Remove all the signatures we currently hold.
*/
  clear(): void;
/**
* Do we hold any signatures or is our collection completely
* empty.
* @returns {boolean}
*/
  isEmpty(): boolean;
/**
* Get the json with all signatures
* @returns {string}
*/
  asJSON(): string;
/**
* How many signatures do we currently hold.
*/
  readonly count: number;
}
/**
* A struct containing an open connection to a CryptoStore.
*
* Opening the CryptoStore can take some time, due to the PBKDF calculation
* involved, so if multiple operations are being done on the same store, it is
* more efficient to open it once.
*/
export class StoreHandle {
  free(): void;
/**
* Open a crypto store.
*
* The created store will be based on IndexedDB if a `store_name` is
* provided; otherwise it will be based on a memory store and once the
* objects is dropped, the keys will be lost.
*
* # Arguments
*
*
* * `store_name` - The name that should be used to open the IndexedDB
*   based database. If this isn't provided, a memory-only store will be
*   used. *Note* the memory-only store will lose your E2EE keys when the
*   `StoreHandle` gets dropped.
*
* * `store_passphrase` - The passphrase that should be used to encrypt the
*   store, for IndexedDB-based stores
* @param {string | undefined} store_name
* @param {string | undefined} store_passphrase
* @returns {Promise<any>}
*/
  static open(store_name?: string, store_passphrase?: string): Promise<any>;
}
/**
* Data for a request to the `/sendToDevice` API endpoint
* ([specification]).
*
* Send an event to a single device or to a group of devices.
*
* [specification]: https://spec.matrix.org/unstable/client-server-api/#put_matrixclientv3sendtodeviceeventtypetxnid
*/
export class ToDeviceRequest {
  free(): void;
/**
* Create a new `ToDeviceRequest`.
* @param {string} id
* @param {string} event_type
* @param {string} txn_id
* @param {string} body
*/
  constructor(id: string, event_type: string, txn_id: string, body: string);
/**
* A JSON-encoded string containing the rest of the payload: `messages`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
/**
* A string representing the type of event being sent to each devices.
*/
  readonly event_type: string;
/**
* The request ID.
* For to-device request this would be the same value as `txn_id`. It is
* exposed also as `id` so that the js bindings are consistent with the
* other request types by using this field to mark as sent.
*/
  readonly id: string;
/**
* A string representing a request identifier unique to the access token
* used to send the request.
*/
  readonly txn_id: string;
/**
* Get its request type.
*/
  readonly type: number;
}
/**
* Type to install and to manipulate the tracing layer.
*/
export class Tracing {
  free(): void;
/**
* Check whether the `tracing` feature has been enabled.
*
* @deprecated: `tracing` is now always enabled.
* @returns {boolean}
*/
  static isAvailable(): boolean;
/**
* Install the tracing layer.
* @param {number} min_level
*/
  constructor(min_level: number);
/**
* Turn the logger on, i.e. it emits logs again if it was turned
* off.
*/
  turnOn(): void;
/**
* Turn the logger off, i.e. it no longer emits logs.
*/
  turnOff(): void;
/**
* Re-define the minimum logger level.
*/
  minLevel: number;
}
/**
* Other Requests * 
* Request that will publish a cross signing identity.
*
* This uploads the public cross signing key triplet.
*/
export class UploadSigningKeysRequest {
  free(): void;
/**
* Create a new `UploadSigningKeysRequest`.
* @param {string} body
*/
  constructor(body: string);
/**
* A JSON-encoded string containing the rest of the payload: `master_key`,
* `self_signing_key`, `user_signing_key`.
*
* It represents the body of the HTTP request.
*/
  readonly body: string;
}
/**
* A read only view over all devices belonging to a user.
*/
export class UserDevices {
  free(): void;
/**
* Get the specific device with the given device ID.
* @param {DeviceId} device_id
* @returns {Device | undefined}
*/
  get(device_id: DeviceId): Device | undefined;
/**
* Returns true if there is at least one devices of this user
* that is considered to be verified, false otherwise.
*
* This won't consider your own device as verified, as your own
* device is always implicitly verified.
* @returns {boolean}
*/
  isAnyVerified(): boolean;
/**
* Array over all the device IDs of the user devices.
* @returns {Array<any>}
*/
  keys(): Array<any>;
/**
* Iterator over all the devices of the user devices.
* @returns {Array<any>}
*/
  devices(): Array<any>;
}
/**
* A Matrix [user ID].
*
* [user ID]: https://spec.matrix.org/v1.2/appendices/#user-identifiers
*/
export class UserId {
  free(): void;
/**
* Parse/validate and create a new `UserId`.
* @param {string} id
*/
  constructor(id: string);
/**
* Whether this user ID is a historical one.
*
* A historical user ID is one that doesn't conform to the latest
* specification of the user ID grammar but is still accepted
* because it was previously allowed.
* @returns {boolean}
*/
  isHistorical(): boolean;
/**
* Return the user ID as a string.
* @returns {string}
*/
  toString(): string;
/**
* Returns the user's localpart.
*/
  readonly localpart: string;
/**
* Returns the server name of the user ID.
*/
  readonly serverName: ServerName;
}
/**
* Struct representing a cross signing identity of a user.
*
* This is the user identity of a user that isn't our own. Other users will
* only contain a master key and a self signing key, meaning that only device
* signatures can be checked with this identity.
*
* This struct wraps a read-only version of the struct and allows verifications
* to be requested to verify our own device with the user identity.
*/
export class UserIdentity {
  free(): void;
/**
* Is this user identity verified?
* @returns {boolean}
*/
  isVerified(): boolean;
/**
* Manually verify this user.
*
* This method will attempt to sign the user identity using our private
* cross signing key.
*
* This method fails if we don't have the private part of our user-signing
* key.
*
* Returns a request that needs to be sent out for the user to be marked as
* verified.
* @returns {Promise<any>}
*/
  verify(): Promise<any>;
/**
* Create a `VerificationRequest` object after the verification
* request content has been sent out.
* @param {RoomId} room_id
* @param {EventId} request_event_id
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  requestVerification(room_id: RoomId, request_event_id: EventId, methods?: Array<any>): Promise<any>;
/**
* Send a verification request to the given user.
*
* The returned content needs to be sent out into a DM room with the given
* user.
*
* After the content has been sent out a VerificationRequest can be started
* with the `request_verification` method.
* @param {Array<any> | undefined} methods
* @returns {Promise<any>}
*/
  verificationRequestContent(methods?: Array<any>): Promise<any>;
/**
* Get the master key of the identity.
*/
  readonly masterKey: string;
/**
* Get the self-signing key of the identity.
*/
  readonly selfSigningKey: string;
}
/**
* An object controlling key verification requests.
*
* Interactive verification flows usually start with a verification
* request, this object lets you send and reply to such a
* verification request.
*
* After the initial handshake the verification flow transitions into
* one of the verification methods.
*/
export class VerificationRequest {
  free(): void;
/**
* Create an event content that can be sent as a room event to
* request verification from the other side. This should be used
* only for verifications of other users and it should be sent to
* a room we consider to be a DM with the other user.
* @param {UserId} own_user_id
* @param {DeviceId} own_device_id
* @param {UserId} other_user_id
* @param {Array<any> | undefined} methods
* @returns {string}
*/
  static request(own_user_id: UserId, own_device_id: DeviceId, other_user_id: UserId, methods?: Array<any>): string;
/**
* Has the verification request been answered by another device?
* @returns {boolean}
*/
  isPassive(): boolean;
/**
* Is the verification request ready to start a verification flow?
* @returns {boolean}
*/
  isReady(): boolean;
/**
* Has the verification flow timed out?
* @returns {boolean}
*/
  timedOut(): boolean;
/**
* The number of milliseconds remaining before this verification flow times
* out.
*
* Returns zero if the time has already passed.
* @returns {number}
*/
  timeRemainingMillis(): number;
/**
* Is this a verification that is verifying one of our own
* devices?
* @returns {boolean}
*/
  isSelfVerification(): boolean;
/**
* Did we initiate the verification request?
* @returns {boolean}
*/
  weStarted(): boolean;
/**
* Has the verification flow that was started with this request
* finished?
* @returns {boolean}
*/
  isDone(): boolean;
/**
* Get the current phase of this request.
*
* Returns a `VerificationRequestPhase`.
* @returns {number}
*/
  phase(): number;
/**
* If this request has transitioned into a concrete verification
* flow (and not yet been completed or cancelled), returns a `Verification`
* object.
*
* Returns: a `Sas`, a `Qr`, or `undefined`.
* @returns {any}
*/
  getVerification(): any;
/**
* Register a callback which will be called whenever there is an update to
* the request.
*
* The `callback` is called with no parameters.
* @param {Function} callback
*/
  registerChangesCallback(callback: Function): void;
/**
* Has the verification flow that was started with this request
* been cancelled?
* @returns {boolean}
*/
  isCancelled(): boolean;
/**
* Accept the verification request signaling that our client
* supports the given verification methods.
*
* `methods` represents the methods that we should advertise as
* supported by us.
*
* It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
* or `undefined`.
* @param {Array<any>} methods
* @returns {any}
*/
  acceptWithMethods(methods: Array<any>): any;
/**
* Accept the verification request.
*
* This method will accept the request and signal that it
* supports the `m.sas.v1`, the `m.qr_code.show.v1`, and
* `m.reciprocate.v1` method.
*
* `m.qr_code.show.v1` will only be signaled if the `qrcode`
* feature is enabled. This feature is disabled by default. If
* it's enabled and QR code scanning should be supported or QR
* code showing shouldn't be supported the `accept_with_methods`
* method should be used instead.
*
* It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
* or `undefined`.
* @returns {any}
*/
  accept(): any;
/**
* Cancel the verification request.
*
* It returns either a `ToDeviceRequest`, a `RoomMessageRequest`
* or `undefined`.
* @returns {any}
*/
  cancel(): any;
/**
* Transition from this verification request into a SAS verification flow.
*
* Returns `Promise<[Sas, RoomMessageRequest|ToDeviceRequest] | undefined>`
* @returns {Promise<any>}
*/
  startSas(): Promise<any>;
/**
* Generate a QR code that can be used by another client to start
* a QR code based verification.
*
* Returns a `Qr` or `undefined`.
* @returns {Promise<any>}
*/
  generateQrCode(): Promise<any>;
/**
* Start a QR code verification by providing a scanned QR code
* for this verification flow.
* @param {QrCodeScan} data
* @returns {Promise<any>}
*/
  scanQrCode(data: QrCodeScan): Promise<any>;
/**
* Get info about the cancellation if the verification request
* has been cancelled.
*/
  readonly cancelInfo: CancelInfo | undefined;
/**
* Get the unique ID of this verification request.
*/
  readonly flowId: string;
/**
* The ID of the other device that is participating in this
* verification.
*/
  readonly otherDeviceId: DeviceId | undefined;
/**
* The ID of the other user that is participating in this
* verification request.
*/
  readonly otherUserId: UserId;
/**
* Get our own supported verification methods that we advertised.
*
* Will be present only we requested the verification or if we’re
* in the ready state.
*/
  readonly ourSupportedMethods: Array<any> | undefined;
/**
* Our own user id.
*/
  readonly ownUserId: UserId;
/**
* Get the room ID if the verification is happening inside a
* room.
*/
  readonly roomId: RoomId | undefined;
/**
* Get the supported verification methods of the other side.
*
* Will be present only if the other side requested the
* verification or if we’re in the ready state.
*
* It return a `Option<Vec<VerificationMethod>>`.
*/
  readonly theirSupportedMethods: Array<any> | undefined;
}
/**
* Object containing the versions of the Rust libraries we are using.
*/
export class Versions {
  free(): void;
/**
* The build-time output of the `git describe` command of the source tree
* of crate.
*/
  readonly git_description: string;
/**
* The Git commit hash of the crate's source tree at build time.
*/
  readonly git_sha: string;
/**
* The version of the matrix-sdk-crypto crate.
*/
  readonly matrix_sdk_crypto: string;
/**
* The version of the vodozemac crate.
*/
  readonly vodozemac: string;
}
/**
 * Load the WebAssembly module in the background, if it has not already been loaded.
 *
 * Returns a promise which will resolve once the other methods are ready.
 *
 * @returns {Promise<void>}
 */
export function initAsync(): Promise<void>;
